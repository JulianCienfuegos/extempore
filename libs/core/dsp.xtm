;;; dsp.xtm -- digital signal processing library for Extempore

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; A library for signal processing in Extmpore.

;;; Code:

;; set *build-multi-chan* to #f if you don't want to compile
;; multichannel extensions
(if (not (defined? '*build-multi-chan*))
    (define *build-multi-chan* #t))

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE double (integer->real *au:samplerate*))
           (bind-val SR double (integer->real *au:samplerate*))))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [double,double,double,double,double*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" SR)))

(print_audio_state)

;; default (silent) audio callback
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))

;;;;;;;;;;;;;;;
;; Utilities ;;
;;;;;;;;;;;;;;;

;;  metronome setup stuff

(bind-val METRO_TEMPO double 120.0)

(bind-func xtlang_tempo_sync
  (lambda (tempo)
    (if (> (fabs (- tempo METRO_TEMPO)) 0.0000001)
        (begin (printf "Setting METRO_TEMPO = %f\n" tempo)
               (set! METRO_TEMPO tempo))
        0.0)))

(define *xtlang-tempo-sync-callback-running* #f)

(define xtlang-tempo-sync-callback
  (lambda (time period)
    (xtlang_tempo_sync (*metro* 'get-tempo))
    (callback (+ time (* 0.5 period))
              'xtlang-tempo-sync-callback
              (+ time period)
              period)))

;; start the tempo sync callback

(if (not *xtlang-tempo-sync-callback-running*)
    (begin (xtlang-tempo-sync-callback (now) 4410)
           (set! *xtlang-tempo-sync-callback-running* #t)))

(bind-func secs2beats
  (lambda (seconds)
    (/ (* METRO_TEMPO seconds) 60.0)))

(bind-func beats2secs
  (lambda (beats)
    (* (/ beats METRO_TEMPO) 60.0)))

(bind-func midi2frq
  (lambda (pitch)
    (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0)))))

(bind-func frq2midi
  (lambda (freq)
    (+ (* 12.0 (log2 (/ freq 440.0))) 69.0)))

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func dsp_randn
  (let ((phase 0))
    (lambda ()
      (let ((u1 (random))
	    (u2 (random))
	    (v1 (- (* 2.0 u1) 1.0))
	    (v2 (- (* 2.0 u2) 1.0))
	    (s (+ (* v1 v1) (* v2 v2))))
	(if (= phase 0)
	    (if (or (> s 1.0) (= s 0.0) (= s 1.0))
		(dsp_randn)
		(* v1 (sqrt (/ (* -2.0 (log s)) s))))
	    (begin (set! phase (- 1 phase))
		   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

;; computationally efficient sin function
;; x values must fall within the range -PI ... PI
(bind-func _sin
  "efficient sin function (arg must be in range [-pi,pi])"
  (let ((p 0.225) ; :_abuf* (alloc))
	(b (/ 4.0 PI))
	(c (/ -4.0 (* PI PI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
	(+ (* p (- (* y (fabs y)) y)) y)))))

;; buffers

(bind-func circular_buffer_c
  (lambda (size)
    (let ((buffer:double* (zalloc size))
          (buf_pos 0))
      (lambda (in)
        (let ((out (pref buffer buf_pos)))
          (pset! buffer buf_pos in)
          (set! buf_pos (modulo (+ buf_pos 1) size))
          out)))))

(if *build-multi-chan*
    (bind-func circular_buffer_mc_c
      (lambda (channels:i64 size)
        (let ((val 0.0)
	      (buffers:[double,double]** (zalloc channels))
              (i 0))
	  (dotimes (i channels) (pset! buffers i (circular_buffer_c size)))
	  (lambda (chan in)
	    ((pref buffers (dtoi64 chan)) in))))))

;;;;;;;;;;;;
;;  UGens ;;
;;;;;;;;;;;;

;; In idiomatic Extempore DSP, closures are used as the basic building
;; blocks of the signal chain, or unit generators (ugens). These ugen
;; closures are stateful, and are called repeatedly (usually at the
;; audio samplerate) to yield successive values which form their
;; output.
;;
;; Any function which returns a closure should have the suffix _c
;;
;; The most basic ugen is a sin oscillator, which is created using the
;; function osc_c. osc_c takes one argument (the starting phase of the
;; returned closure) and returns a closure which takes two arguments
;; (the frequency and amplitude of the oscillator). There are also
;; other oscillators, including square waves, triangle waves, and
;; white and pink noise.

;; basic impulse (dirac delta) function

(bind-func dirac_c
  "returns an impulse response closure (offset in samples)"
  (lambda (offset)
    (let ((n 0))
      (lambda ()
        (if (= n offset)
            (begin (set! n (+ n 1)) 1.0)
            (begin (set! n (+ n 1)) 0.0))))))

(if *build-multi-chan*
    (bind-func dirac_mc_c
      (lambda (offset)
        (let ((val 0.0)
	      (impulse (dirac_c offset)))
	  (lambda (chan)
	    (if (< chan 1.0) (set! val (impulse)))
	    val)))))

(bind-func heaviside_c
  "returns a heaviside step function ugen closure"
  (lambda (offset)
    (let ((n 0))
      (lambda ()
        (if (< n offset)
            (begin (set! n (+ n 1)) 0.0)
            (begin (set! n (+ n 1)) 1.0))))))

(if *build-multi-chan*
    (bind-func heaviside_mc_c
      (lambda (offset)
        (let ((val 0.0)
	      (heaviside (heaviside_c offset)))
	  (lambda (chan)
	    (if (< chan 1.0) (set! val (heaviside)))
	    val)))))

(bind-func accum_c
  "returns an accumulator closure"
  (lambda ()
    (let ((sum 0.0))
      (lambda (in)
        (set! sum (+ sum in))
        sum))))

;; noise oscillators

(bind-func white_c
  "returns a gaussian white noise ugen closure"
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  "returns a pink noise ugen closure"
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; must be called at audio sample rate
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse_c
  (lambda ()
    (let ((samp 0.0))
      (lambda (apex:double)
        (let ((h (* samp apex)))
          (set! samp (+ samp 1.0))
          (* h (exp (- 1.0 h))))))))

(if *build-multi-chan*
    (bind-func impulse_mc_c
      (lambda ()
        (let ((val 0.0)
	      (impulse (impulse_c)))
	  (lambda (chan apex)
	    (if (< chan 1.0) (set! val (impulse apex)))
	    val)))))

;; uses _sin for efficiency
(bind-func osc_c
  "returns a sin oscillator"
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* TWOPI (/ freq SR))))
	(set! phase (+ phase inc))
	(if (> phase PI) (set! phase (- phase TWOPI)))
	(* amp (_sin phase))))))

(if *build-multi-chan*
    (bind-func osc_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (osc (osc_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (osc amp freq)))
	    val)))))

;; a hann window of length N
(bind-func hann
  (lambda (n N)
    (let ((val (_sin (/ (* PI n)
                        (- N 1.0)))))
      (* val val))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_c
  "returns a square wave ugen closure"
  (lambda (phase)
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
        (* amp (tanh (* n (osc 1.0 freq))))))))

;; square oscillator multichannel
(if *build-multi-chan*
    (bind-func square_mc_c
      (lambda (phase)
	(let ((sqr (square_c phase))
	      (val 0.0))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! val (sqr amp freq n)))
	    val)))))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_c
  "returns a triangle wave ugen closure"
  (lambda (phase)
    (let ((osc (osc_c phase))
          (old 0.0)
          (new 0.0)
          (leak 0.9))
      (lambda (amp freq n)
        (set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

(if *build-multi-chan*
    (bind-func triangle_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (tri (triangle_c phase)))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! val (tri amp freq n)))
	    val)))))

;; pulse wave oscillator - useful for pulse width modulation
(bind-func pulse_c
  "returns a pulse wave ugen closure (duty [0.0,1.0])"
  (let ()
    (lambda (phase)
      (lambda (amp freq duty)
        (let ((inc (/ freq SR)))
          (set! phase (+ phase inc))
          (if (> phase 1.0) (set! phase (- phase 1.0)))
          (if (< phase duty) amp (* -1.0 amp)))))))

(if *build-multi-chan*
    (bind-func rect_mc_c
      (let ()
        (lambda (phase)
          (let ((val 0.0)
                (pulse (pulse_c phase)))
            (lambda (chan amp freq duty)
              (if (< chan 1.0) (set! val (pulse amp freq duty)))
              val))))))

;; saw oscillator
(bind-func saw_c
  "returns a saw ugen closure"
  (lambda (phase)
    (let ((dp 1.0)
	  (x 0.0)
	  (leak 0.995)
	  (saw 0.0))
      (lambda (amp freq)
	(let* ((qmax (* 0.5 (/ SR freq)))
	       (dc (/ -0.498 qmax)))
	  (set! phase (+ phase dp))
	  (if (< phase 0.0)
	      (begin (set! phase (- 0.0 phase))
		     (set! dp (- 0.0 dp)))
	      (if (> phase qmax)
		  (begin (set! phase (+ qmax (- qmax phase)))
			 (set! dp (- 0.0 dp)))))
	  (set! x (* PI phase))
	  (if (< x 0.000001) (set! x 0.00001))
	  (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
	  (* amp saw))))))

;; saw oscillator
(if *build-multi-chan*
    (bind-func saw_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (saw (saw_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (saw amp freq)))
	    val)))))

;; ugens for returning straight lines
;; useful for controlling other paramaters
(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:double end:double dur:double)
      (let ((m (/ (- end start) dur))
	     (b (- end (* m dur))))
        (lambda (inc)
          (set! time (+ time inc))
	  (+ (* m time) b))))))

(if *build-multi-chan*
    (bind-func linear_mc_c
      (let ((time 0.0))
        (lambda (start:double end:double dur:double)
          (let* ((m (/ (- end start) dur))
                 (c (- end (* m dur))))
            (lambda (chan inc)
              (if (< chan 0.5)
                  (set! time (+ time inc)))
              (+ (* m time) c)))))))

;; 'fade' closure
;; differs from linear by being tempo-based
;; output: 'initial' for t < 0, 'final' for time > duration
(bind-func fade_c
  (lambda (phase)
    (lambda (initial:double final dur)
      (let ((inc (/ 1.0 (* (beats2secs dur) SR))))
        (set! phase (+ phase inc))
        (if (< phase 0.0)
            initial
            (if (> phase 1.0)
                final
            (* phase (- final initial))))))))

(if *build-multi-chan*
    (bind-func fade_mc_c
      (lambda (phase)
        (let ((val 0.0)
	      (fade (fade_c phase)))
	  (lambda (chan initial final dur)
	    (if (< chan 1.0) (set! val (fade initial final dur)))
	    val)))))

;;;;;;;;;;;;;
;; filters ;;
;;;;;;;;;;;;;

;; bi-quad IIR filters these filters are all computationally cheap,
;; but there may be stability issues as the resonance parameter is
;; pushed near its limits

(bind-func allpass_c
  (lambda (delay)
    (let ((_delay (dtoi64 delay))
          (inline:double* (zalloc _delay))
	  (outline:double* (zalloc _delay))
	  (time 0))
      (lambda (in feedback)
	(let* ((n (modulo time _delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (out (+ (* -1.0 feedback in)
                       dx
                       (* feedback dy))))
	  (pset! inline n in)
	  (pset! outline n out)
	  (set! time (+ time 1))
	  out)))))

(if *build-multi-chan*
    (bind-func allpass_mc_c
      (lambda (channels:i64 delay)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (allpass_c delay)))
	  (lambda (chan in wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in wet)))))))

;; biquad low-pass filter
(bind-func lpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_cutoff 0.0)
	   (_resonance 0.0))
      (lambda (in cutoff resonance)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> resonance _resonance))
	    (let* ((omega (* TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 resonance))))
	      (set! _cutoff cutoff)
	      (set! _resonance resonance)
	      (set! b0 (/ (- 1.0 coso) 2.0))
	      (set! b1 (- 1.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func lpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lpf_c)))
	  (lambda (chan in cutoff resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff resonance)))))))

;; biquad high-pass filter
(bind-func hpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_resonance 0.0)
	   (_cutoff 0.0))
      (lambda (in cutoff resonance)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> resonance _resonance))
	    (let* ((omega (* TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 resonance))))
	      (set! _cutoff cutoff)
	      (set! _resonance resonance)
	      (set! b0 (/ (+ 1.0 coso) 2.0))
	      (set! b1 (* -1.0 (+ 1.0 coso)))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func hpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hpf_c)))
	  (lambda (chan in cutoff resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff resonance)))))))

;; biquad band-pass filter
(bind-func bpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_cutoff 0.0)
	   (_bandwidth 0.0))
      ;; bandwidth in octaves
      (lambda (in cutoff bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> bandwidth _bandwidth))
	    (let* ((omega (* 1.0 TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! _cutoff cutoff)
	      (set! _bandwidth bandwidth)
	      (set! b0 alpha)
	      (set! b1 0.0)
	      (set! b2 (* -1.0 b0))
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func bpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (bpf_c)))
	  (lambda (chan in cutoff bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff bandwidth)))))))

(bind-func notch_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_freq 0.0)
	   (_bandwidth 0.0))
      ;; bandwidth in octaves
      (lambda (in freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 1.0)
	      (set! b1 (* -2.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 b1)
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func notch_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (notch_c)))
	  (lambda (chan in freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in freq bandwidth)))))))

;; biquad peaking band EQ filter
(bind-func peak_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
	   (_db_gain 0.0)
	   (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino)))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (+ 1.0 (* alpha A)))
	      (set! b1 (* -2.0 coso))
	      (set! b2 (- 1.0 (* alpha A)))
	      (set! a0 (+ 1.0 (/ alpha A)))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 (/ alpha A)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func peak_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (peak_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))


;; biquad low-shelf filter
(bind-func lsf_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
           (_db_gain 0.0)
           (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if args change, re-calculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino))))
                   (beta (sqrt (+ A A))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (* A (+ (- (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! b1 (* 2.0 A (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! b2 (* A (- (- (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! a0 (+ (+ A 1.0)
                          (* (- A 1.0) coso)
                          (* beta sino)))
	      (set! a1 (* -2.0 (+ (- A 1.0) (* (+ A 1.0) coso))))
	      (set! a2 (- (+ (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func lsf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lsf_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))


;; biquad high-shelf filter
(bind-func hsf_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
           (_db_gain 0.0)
           (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if args change, re-calculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino))))
                   (beta (sqrt (+ A A))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (* A (+ (+ (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! b1 (* -2.0 A (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! b2 (* A (- (+ (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! a0 (+ (- (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))
	      (set! a1 (* 2.0 (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! a2 (- (- (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func hsf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hsf_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))

;; a moog-style voltage-controlled filter

(bind-func vcf_c
  "moog VCF: type is 1 (lpf), 2 (hpf) or 3 (bpf)"
  (lambda (type)
    (let ((x 0.0)
          (y1 0.0)
          (y2 0.0)
          (y3 0.0)
          (y4 0.0)
	  (_x 0.0)
          (_y1 0.0)
          (_y2 0.0)
          (_y3 0.0))
      (lambda (in cutoff resonance)
	(let ((f (* 1.75 (/ cutoff SR)))
              ;;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* resonance scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* _x  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* _y1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* _y2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* _y3 p) (* -1.0 k y4)))
	  (set! _x x) (set! _y1 y1) (set! _y2 y2) (set! _y3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
	  ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
	  (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))

(if *build-multi-chan*
    (bind-func vcf_mc_c
      (lambda (type:i64 channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf_c type)))
	  (lambda (chan x freq resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq resonance)))))))

;;;;;;;;
;; FX ;;
;;;;;;;;

;; Basically, this means anything which takes an input as well as an
;; output.

(bind-func hard_clip
  (lambda (in:double up_lim low_lim)
    (if (< in low_lim) low_lim
	(if (> in up_lim) up_lim
	    in))))

(bind-func soft_clip
  "softly clip input value into range [-1,1]"
  (lambda (in)
    (tanh in)))

;; distortion
;; can cascade several of these for more overdrive
(bind-func waveshape
  (lambda (in distortion)
    (* in
       (/ (+ distortion (fabs in))
          (+ (* in in)
             (* (- distortion 1.0) (fabs in))
             1.0)))))

(bind-func distortion
  (lambda (in gain)
    (tanh (* in gain)))) 

(bind-func bitcrush
  (lambda (in bits)
    (/ (floor (* in (pow 2. bits)))
       (pow 2. bits))))

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda ()
    (let ((drive_ 1.0)
          (drive_minus_1 (- drive_ 1.0)))
      (lambda (in drive)
        (if (<> drive drive_)
            (begin (set! drive drive_)
                   (set! drive_minus_1 (- drive 1.0))))
        (let ((absval (fabs in)))
          (/ (* in (+ absval drive))
             (+ (* in in)
                (* drive_minus_1 absval)
                1.0)))))))

(if *build-multi-chan*
    (bind-func overdrive_mc_c
      (lambda (nchan:i64)
        (let ((overdrive_buf:[double,double,double]** (zalloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! overdrive_buf i (overdrive_c)))
	  (lambda (chan in drive)
	    ((pref overdrive_buf (dtoi64 chan)) in drive))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (in drive character)
        (let ((q (- drive 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= in q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- in q)
                            (+ (- 1.0 (exp (* -1.0 dist (- in q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(if *build-multi-chan*
    (bind-func saturation_mc_c
      (lambda (nchan:i64)
        (let ((saturation_buf:[double,double,double,double]** (zalloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! saturation_buf i (saturation_c)))
	  (lambda (chan in drive character)
	    ((pref saturation_buf (dtoi64 chan)) in drive character))))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (in freq feedback)
        (+ (* (- 1.0 feedback) in)
           (* feedback (* in (osc freq 1.0))))))))

(if *build-multi-chan*
    (bind-func ringmod_mc_c
      (lambda (nchan:i64)
        (let ((ringmod_buf:[double,double,double,double]** (zalloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! ringmod_buf i (ringmod_c)))
	  (lambda (chan in freq feedback)
	    ((pref ringmod_buf (dtoi64 chan)) in freq feedback))))))

;; delays

(bind-func del_c
  "simple, efficient delay (no resizing, no bounds checks)"
  (lambda (delay)
    (let ((line:double* (zalloc delay))
          (line_idx 0)
          (out 0.0))
      (lambda (in:double wet feedback)
        (set! out (pref line line_idx))
        (pset! line line_idx (* feedback (+ in out)))
        (set! line_idx (+ 1 (modulo line_idx delay)))
        (+ in (* out wet))))))

(if *build-multi-chan*
    (bind-func del_mc_c
      (lambda (nchan:i64 delay)
        (let ((dlines:[double,double,double,double]** (alloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! dlines i (del_c delay)))
          (lambda (chan in wet feedback)
            ((pref dlines (dtoi64 chan)) in wet feedback))))))

;; This delay is less efficient, but safer and also 'metronome-aware'.
;; Arguments are doubles and represent a delay time in beats (at the
;; current tempo)
(bind-func delay_c
  "a delay effect (all delays in beats)"
  (lambda (max_delay)
    (let ((delay max_delay)
          (_delay 0.0)
          (line_length (dtoi64 (* (beats2secs max_delay) SR)))
          ;; allocate more memory, in case the tempo slows down
          (line_overallocation_factor 2)
	  (line:double* (zalloc (* line_overallocation_factor line_length)))
          (line_idx 0)
          (out 0.0))
      (lambda (in:double wet feedback)
        (if (<> _delay delay)
            (if (> (/ delay max_delay) (i64tod line_overallocation_factor))
                (begin (printf "Error: delay exceeding initial buffer length!\n")
                       0.0)
                (begin (set! line_length (dtoi64 (* (beats2secs delay) SR)))
                       (set! _delay delay))))
        (set! out (pref line line_idx))
        (pset! line line_idx (* feedback (+ in out)))
        (set! line_idx (+ 1 (modulo line_idx line_length)))
        (+ in (* out wet))))))

(if *build-multi-chan*
    (bind-func delay_mc_c
      (lambda (nchan:i64 max_delay)
        (let ((dlines:[double,double,double,double]** (zalloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! dlines i (delay_c max_delay)))
          (lambda (chan in wet feedback)
            ((pref dlines (dtoi64 chan)) in wet feedback))))))

(bind-func tap_delay_c
  "a tap delay effect (max_delay, tap locations in beats)"
  (lambda (max_delay ntaps)
    (let ((_num_taps ntaps)
          (line_length (dtoi64 (* 1.5 (beats2secs max_delay) SR)))
          (line:double* (zalloc line_length))
          (line_idx 0)
          (taps:double* (zalloc ntaps))
          (norm_gain (/ 1.0 (i64tod ntaps)))
          (out 0.0)
          (i 0))
      (lambda (in:double)
        (if (<> _num_taps ntaps)
            (begin (set! norm_gain (/ 1.0 (i64tod ntaps)))
                   (set! _num_taps ntaps)))
        (set! out 0.0)
        (pset! line line_idx in)
        (dotimes (i ntaps)
          (set! out (+ out (* norm_gain (pref line (modulo (- line_idx (dtoi64 (* (beats2secs (pref taps i)) SR))) line_length))))))
        (set! line_idx (+ 1 (modulo line_idx line_length)))
        out))))

(if *build-multi-chan*
    (bind-func tap_delay_mc_c
      (lambda (nchan:i64 max_delay ntaps)
        (let ((tap_delay_buf:[double,double]** (zalloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! tap_delay_buf i (tap_delay_c max_delay ntaps)))
	  (lambda (chan in)
	    ((pref tap_delay_buf (dtoi64 chan)) in))))))

(bind-func comb_c
  "IIR comb with interpolation"
  (lambda (max_delay)
    (let ((maxdelay (dtoi64 max_delay))
          (line:double* (zalloc maxdelay))
	  (in_head 0)
	  (out_head 0)
	  (_delay max_delay)
	  (alpha 0.0)
	  (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (in:double delay:double wet feedback)
	(if (<> delay _delay)
	    (begin (set! _delay delay)
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ maxdelay in_head)
				     (dtoi64 delay)))))
	(set! ih (modulo in_head maxdelay))
	(set! oh (modulo out_head maxdelay))
	(set! delayed1 (pref line oh))
	(set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
	(set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
	;;(set! y (+ (* in in) (* out delayed)))
        (pset! line ih (* feedback (+ in delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ in (* delayed wet))))))

(if *build-multi-chan*
    (bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
	  (lambda (chan in delay wet feedback)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f in delay wet feedback)))))))

;; flanger
(bind-func flanger_c
  (lambda (delay mod_phase mod_range mod_rate)
    (let ((comb (comb_c (+ delay mod_range)))
	  (mod (osc_c mod_phase)))
      (lambda (in:double wet feedback)
	(comb in (+ delay (mod mod_range mod_rate)) wet feedback)))))

(if *build-multi-chan*
    (bind-func flanger_mc_c
      (lambda (channels:i64 delay mod_phase mod_range mod_rate)
	(let ((comb (comb_mc_c channels (+ delay mod_range)))
	      (mod (osc_mc_c mod_phase))
	      (i:i64 0))
	  (lambda (chan in wet feedback)
	    (comb chan in (+ delay (mod chan mod_range mod_rate)) wet feedback))))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay 700.0)
	  (range 200.0)
	  (rate 0.1)
	  (comb1 (comb_c (+ delay range)))
	  (comb2 (comb_c (+ delay range)))
	  (comb3 (comb_c (+ delay range)))
	  (mrng1 range)
	  (mrng2 (* (random) range))
	  (mrng3 (* (random) range))
	  (mrte1 rate)
	  (mrte2 (* rate 1.372))
	  (mrte3 (* rate 0.792))
	  (dly1 delay)
	  (dly2 (* (random) delay))
	  (dly3 (* (random) delay))
	  (mod1 (osc_c phase))
	  (mod2 (osc_c phase))
	  (mod3 (osc_c phase)))
      (lambda (in:double wet fb)
	(+ (comb1 in (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
	   (comb2 in (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
	   (comb3 in (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(if *build-multi-chan*
    (bind-func chorus_mc_c
      (lambda (channels:i64 phase)
	(let ((dlines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (chorus_c phase)))
	  (lambda (chan in wet fb)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f in wet fb)))))))

;; reverb
(bind-func reverb_c
  "reverb closure (size in milliseconds)"
  (lambda (size)
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (del_c (dtoi64 (* ms (* .192 size)))))
	  (dly2 (del_c (dtoi64 (* ms (* .373 size)))))
	  (dly3 (del_c (dtoi64 (* ms (* .671 size)))))
	  (dly4 (del_c (dtoi64 (* ms (* .712 size)))))
	  (ap1 (allpass_c (* ms size)))
	  (ap3 (allpass_c (* ms (* .929 size))))
	  (ap2 (allpass_c (* ms (* .329 size)))))
      (lambda (in wet fb)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (* .3 (+ (dly1 wetin 1.0 fb)
                                     (dly2 wetin 1.0 fb)
                                     (dly3 wetin 1.0 fb)
                                     (dly4 wetin 1.0 fb)))
                            .8)
                       .7)
                  .6)))))))

(if *build-multi-chan*
    (bind-func reverb_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb_c size)))
	  (lambda (chan x wet fb)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet fb)))))))


;; another (lighter-weight) reverb
(bind-func reverb2_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (ap1 (allpass_c (* ms size)))
	  (ap3 (allpass_c (* ms (* .929 size))))
	  (ap2 (allpass_c (* ms (* .329 size)))))
      (lambda (in wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 wetin .8) .7) .6)))))))


(if *build-multi-chan*
    (bind-func reverb2_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb2_c size)))
	  (lambda (chan x wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func hold_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in h:double)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))

(if *build-multi-chan*
    (bind-func hold_mc_c
      (lambda (channels:i64)
	(let ((holds:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! holds i (hold_c)))
	  (lambda (chan x h)
	    (let ((f (pref holds (dtoi32 chan))))
	      (f x h)))))))


;;;;;;;;;;;;
;; mixing ;;
;;;;;;;;;;;;

;; simple stereo weights
(bind-func mix2
  (lambda (x:double chan left right)
    (cond ((< chan 0.5) (* x left))
          ((< chan 1.5) (* x right))
          (else 0.0))))

;; simple quad weights
(bind-func mix4
  (lambda (x:double chan c1 c2 c3 c4)
    (cond ((< chan 0.5) (* x c1))
	  ((< chan 1.5) (* x c2))
	  ((< chan 2.5) (* x c3))
	  ((< chan 3.5) (* x c4))
	  (else 0.0))))

;; a four channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (let ((ch (i64tod channels)))
      (lambda (cdat:double* chan:double in:double)
	(if (< chan channels)
	    (* in (pref cdat (dtoi32 chan)))
	    0.0)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; instrument utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; used in libs/core/instruments.xtm

(bind-func line_c
  (lambda (x1:double y1:double x2 y2)
    (let* ((m (if (= 0.0 (- x2 x1))
		  0.0
		  (/ (- y2 y1) (- x2 x1))))
	   (b (- y2 (* m x2))))
      (lambda (x) (+ (* m x) b)))))

(bind-func envelope_segments
  (lambda (points:double* npoints:i64)
    (let ((lines:[double,double]** (zalloc npoints))
	  (k 0))
      (dotimes (k npoints)
	(let* ((idx (* k 2))
	       (x1 (pref points (+ idx 0)))
	       (y1 (pref points (+ idx 1)))
	       (x2 (pref points (+ idx 2)))
	       (y2 (pref points (+ idx 3))))
	  (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:double* npoints)
    (let ((klines:[double,double]** (envelope_segments points npoints))
	  (line_length npoints))
      (lambda (time)
	(let ((res -1.0)
	      (k:i64 0))
	  (dotimes (k npoints)
	    (let ((line (pref klines k))
		  (time_point (pref points (* k 2))))
	      (if (or (= time time_point)
		      (< time_point time))
		  (set! res (line time)))))
	  res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time adur ddur sdur rdur peak_amp sus_amp)
    (let* ((points 6)
	   (data:double* (zalloc (* points 2))))
      (pset! data 0 start_time)
      (pset! data 1 0.0)
      (pset! data 2 (+ start_time adur)) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (+ start_time adur ddur))
      (pset! data 5 sus_amp)
      (pset! data 6 (+ start_time adur ddur sdur))
      (pset! data 7 sus_amp)
      (pset! data 8 (+ start_time adur ddur sdur rdur))
      (pset! data 9 0.0)
      (pset! data 10 (+ start_time adur ddur sdur rdur 1.0)) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
	(lambda (time:double)
	  (f time))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:double adur ddur sdur rdur peak_amp sus_amp)
    (let ((val (if (> (+ adur ddur) 1.0) 0.0 peak_amp))
	  (t1 adur)
	  (t2 (+ adur ddur))
	  (t3 (+ adur ddur sdur))
	  (t4 (+ adur ddur sdur rdur))
	  (inc1 (/ peak_amp adur))
	  (inc2 (* -1.0 (/ (- peak_amp sus_amp) ddur)))
	  (inc3 (* -1.0 (/ sus_amp rdur))))
      (lambda (time:double chan)
	(if (< chan 1.0)
	    (cond ((> time t4) (set! val 0.0))
		  ((> time t3) (set! val (+ val inc3)))
		  ((> time t2) val) ;; sustain (don't do anything with val)
		  ((> time t1) (set! val (+ val inc2)))
		  ((> time 0) (set! val (+ val inc1)))
		  (else (set! val 0.0))))
	val))))

(bind-func hermite_interp
  (lambda (fractional y1:double x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
	  (v (- x0 x1))
	  (w (+ c v))
	  (a (+ w v (* (- x2 x0) 0.5)))
	  (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))
