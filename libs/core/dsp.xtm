;;; dsp.xtm -- digital signal processing library

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; A library for signal processing in Extmpore.

;;; Code:



;; set *build-multi-chan* to #t to compile multichannel extensions
(if (not (defined? '*build-multi-chan*))
    (define *build-multi-chan* #t))

;;;;;;;;;;;;;;;;;;;
;; DSP utilities ;;
;;;;;;;;;;;;;;;;;;;

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE double (integer->real *au:samplerate*))
           (bind-val SR double (integer->real *au:samplerate*))))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [double,double,double,double,double*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" SR)))

(print_audio_state)

;;  metronome setup stuff

;; TODO need to set this up

;; default (silent) audio callback
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))

;;;;;;;;;;;;;;;
;; Utilities ;;
;;;;;;;;;;;;;;;

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func dsp_randn
  (let ((phase 0))
    (lambda ()
      (let ((u1 (random))
	    (u2 (random))
	    (v1 (- (* 2.0 u1) 1.0))
	    (v2 (- (* 2.0 u2) 1.0))
	    (s (+ (* v1 v1) (* v2 v2))))
	(if (= phase 0)
	    (if (or (> s 1.0) (= s 0.0) (= s 1.0))
		(dsp_randn)
		(* v1 (sqrt (/ (* -2.0 (log s)) s))))
	    (begin (set! phase (- 1 phase))
		   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

(bind-func hard_limit
  (lambda (in:double up_lim low_lim)
    (if (< in low_lim) low_lim
	(if (> in up_lim) up_lim
	    in))))

(bind-func limiter_c
  (lambda (up_lim low_lim)
    (lambda (in)
      (hard_limit in up_lim low_lim))))

;; computationally efficient sin function
;; x values must fall within the range -PI ... PI
(bind-func _sin
  "efficient sin function (arg must be in range [-pi,pi])"
  (let ((p 0.225) ; :_abuf* (alloc))
	(b (/ 4.0 PI))
	(c (/ -4.0 (* PI PI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
	(+ (* p (- (* y (fabs y)) y)) y)))))

;;;;;;;;;;;;
;;  UGens ;;
;;;;;;;;;;;;

;; In idiomatic Extempore DSP, closures are used as the basic building
;; blocks of the signal chain, or unit generators (ugens). These ugen
;; closures are stateful, and are called repeatedly (usually at the
;; audio samplerate) to yield successive values which form their
;; output.
;;
;; Any function which returns a closure should have the suffix _c
;;
;; The most basic ugen is a sin oscillator, which is created using the
;; function osc_c. osc_c takes one argument (the starting phase of the
;; returned closure) and returns a closure which takes two arguments
;; (the frequency and amplitude of the oscillator). There are also
;; other oscillators, including square waves, triangle waves, and
;; white and pink noise.

;; basic impulse (dirac delta) function

(bind-func impulse_c
  "returns an impulse response closure (offset in samples)"
  (lambda (offset)
    (let ((n 0))
      (lambda ()
        (if (= n offset)
            (begin (set! n (+ n 1)) 1.0)
            (begin (set! n (+ n 1)) 0.0))))))

(if *build-multi-chan*
    (bind-func impulse_mc_c
      (lambda (offset)
        (let ((val 0.0)
	      (impulse (impulse_c offset)))
	  (lambda (chan)
	    (if (< chan 1.0) (set! val (impulse)))
	    val)))))

(bind-func heaviside_c
  "returns a heaviside step function ugen closure"
  (lambda (offset)
    (let ((n 0))
      (lambda ()
        (if (< n offset)
            (begin (set! n (+ n 1)) 0.0)
            (begin (set! n (+ n 1)) 1.0))))))

(if *build-multi-chan*
    (bind-func heaviside_mc_c
      (lambda (offset)
        (let ((val 0.0)
	      (heaviside (heaviside_c offset)))
	  (lambda (chan)
	    (if (< chan 1.0) (set! val (heaviside)))
	    val)))))

(bind-func accum_c
  "returns an accumulator closure"
  (lambda ()
    (let ((sum 0.0))
      (lambda (in)
        (set! sum (+ sum in))
        sum))))

;; noise oscillators

(bind-func white_c
  "returns a gaussian white noise ugen closure"
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  "returns a pink noise ugen closure"
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; uses _sin for efficiency
(bind-func osc_c
  "returns a sin oscillator"
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* TWOPI (/ freq SR))))
	(set! phase (+ phase inc))
	(if (> phase PI) (set! phase (- phase TWOPI)))
	(* amp (_sin phase))))))

(if *build-multi-chan*
    (bind-func osc_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (osc (osc_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (osc amp freq)))
	    val)))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_c
  "returns a square wave ugen closure"
  (lambda (phase)
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
        (* amp (tanh (* n (osc 1.0 freq))))))))

;; square oscillator multichannel
(if *build-multi-chan*
    (bind-func square_mc_c
      (lambda (phase)
	(let ((sqr (square_c phase))
	      (val 0.0))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! val (sqr amp freq n)))
	    val)))))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_c
  "returns a triangle wave ugen closure"
  (lambda (phase)
    (let ((osc (osc_c phase))
          (old 0.0)
          (new 0.0)
          (leak 0.9))
      (lambda (amp freq n)
        (set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

(if *build-multi-chan*
    (bind-func triangle_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (tri (triangle_c phase)))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! val (tri amp freq n)))
	    val)))))

;; pulse wave oscillator - useful for pulse width modulation
(bind-func pulse_c
  "returns a pulse wave ugen closure (duty [0.0,1.0])"
  (let ()
    (lambda (phase)
      (lambda (amp freq duty)
        (let ((inc (/ freq SR)))
          (set! phase (+ phase inc))
          (if (> phase 1.0) (set! phase (- phase 1.0)))
          (if (< phase duty) amp (* -1.0 amp)))))))

(if *build-multi-chan*
    (bind-func rect_mc_c
      (let ()
        (lambda (phase)
          (let ((val 0.0)
                (pulse (pulse_c phase)))
            (lambda (chan amp freq duty)
              (if (< chan 1.0) (set! val (pulse amp freq duty)))
              val))))))

;; saw oscillator
(bind-func saw_c
  "returns a saw ugen closure"
  (lambda (phase)
    (let ((dp 1.0)
	  (x 0.0)
	  (leak 0.995)
	  (saw 0.0))
      (lambda (amp freq)
	(let* ((qmax (* 0.5 (/ SR freq)))
	       (dc (/ -0.498 qmax)))
	  (set! phase (+ phase dp))
	  (if (< phase 0.0)
	      (begin (set! phase (- 0.0 phase))
		     (set! dp (- 0.0 dp)))
	      (if (> phase qmax)
		  (begin (set! phase (+ qmax (- qmax phase)))
			 (set! dp (- 0.0 dp)))))
	  (set! x (* PI phase))
	  (if (< x 0.000001) (set! x 0.00001))
	  (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
	  (* amp saw))))))

;; saw oscillator
(if *build-multi-chan*
    (bind-func saw_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (saw (saw_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (saw amp freq)))
	    val)))))

(bind-func delayline_c
  (lambda (size)
    (let ((buffer:double* (zalloc (* 2 size)))
          (buf_pos 0))
      (lambda (in)
        (let ((out (pref buffer buf_pos)))
          (pset! buffer buf_pos in)
          (set! buf_pos (modulo (+ buf_pos 1) size))
          out)))))

(if *build-multi-chan*
    (bind-func delayline_mc_c
      (lambda (size num_chan)
        (let ((val 0.0)
	      (delaylines:[double,double]* (zalloc num_chan))
              (i 0))
          (dotimes (i num_chan)
            (pset! delaylines i (delayline_c size)))
	  (lambda (chan in)
	    ((pref delaylines (dtoi64 chan)) in))))))

;;;;;;;;;;;;;
;; filters ;;
;;;;;;;;;;;;;

;; bi-quad IIR filters these filters are all computationally cheap,
;; but there may be stability issues as the resonance parameter is
;; pushed near it's limits

(bind-func allpass_c
  (lambda (delay)
    (let ((_delay (dtoi64 delay))
          (inline:double* (zalloc _delay))
	  (outline:double* (zalloc _delay))
	  (time 0))
      (lambda (in feedback)
	(let* ((n (modulo time _delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (out (+ (* -1.0 feedback in)
                       dx
                       (* feedback dy))))
	  (pset! inline n in)
	  (pset! outline n out)
	  (set! time (+ time 1))
	  out)))))

(if *build-multi-chan*
    (bind-func allpass_mc_c
      (lambda (channels:i64 delay)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (allpass_c delay)))
	  (lambda (chan in wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in wet)))))))

;; biquad low-pass filter
(bind-func lpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_cutoff 0.0)
	   (_resonance 0.0))
      (lambda (in cutoff resonance)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> resonance _resonance))
	    (let* ((omega (* TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 resonance))))
	      (set! _cutoff cutoff)
	      (set! _resonance resonance)
	      (set! b0 (/ (- 1.0 coso) 2.0))
	      (set! b1 (- 1.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func lpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lpf_c)))
	  (lambda (chan in cutoff resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff resonance)))))))

;; biquad high-pass filter
(bind-func hpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_resonance 0.0)
	   (_cutoff 0.0))
      (lambda (in cutoff resonance)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> resonance _resonance))
	    (let* ((omega (* TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 resonance))))
	      (set! _cutoff cutoff)
	      (set! _resonance resonance)
	      (set! b0 (/ (+ 1.0 coso) 2.0))
	      (set! b1 (* -1.0 (+ 1.0 coso)))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func hpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hpf_c)))
	  (lambda (chan in cutoff resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff resonance)))))))

;; biquad band-pass filter
(bind-func bpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_cutoff 0.0)
	   (_bandwidth 0.0))
      ;; bandwidth in octaves
      (lambda (in cutoff bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> bandwidth _bandwidth))
	    (let* ((omega (* 1.0 TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! _cutoff cutoff)
	      (set! _bandwidth bandwidth)
	      (set! b0 alpha)
	      (set! b1 0.0)
	      (set! b2 (* -1.0 b0))
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func bpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (bpf_c)))
	  (lambda (chan in cutoff bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff bandwidth)))))))

(bind-func notch_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_freq 0.0)
	   (_bandwidth 0.0))
      ;; bandwidth in octaves
      (lambda (in freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 1.0)
	      (set! b1 (* -2.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 b1)
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func notch_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (notch_c)))
	  (lambda (chan in freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in freq bandwidth)))))))

;; biquad peaking band EQ filter
(bind-func peak_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
	   (_db_gain 0.0)
	   (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino)))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (+ 1.0 (* alpha A)))
	      (set! b1 (* -2.0 coso))
	      (set! b2 (- 1.0 (* alpha A)))
	      (set! a0 (+ 1.0 (/ alpha A)))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 (/ alpha A)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func peak_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (peak_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))


;; biquad low-shelf filter
(bind-func lsf_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
           (_db_gain 0.0)
           (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if args change, re-calculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino))))
                   (beta (sqrt (+ A A))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (* A (+ (- (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! b1 (* 2.0 A (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! b2 (* A (- (- (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! a0 (+ (+ A 1.0)
                          (* (- A 1.0) coso)
                          (* beta sino)))
	      (set! a1 (* -2.0 (+ (- A 1.0) (* (+ A 1.0) coso))))
	      (set! a2 (- (+ (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func lsf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lsf_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))


;; biquad high-shelf filter
(bind-func hsf_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
           (_db_gain 0.0)
           (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if args change, re-calculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino))))
                   (beta (sqrt (+ A A))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (* A (+ (+ (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! b1 (* -2.0 A (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! b2 (* A (- (+ (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! a0 (+ (- (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))
	      (set! a1 (* 2.0 (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! a2 (- (- (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func hsf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hsf_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))

;; a moog-style voltage-controlled filter

(bind-func vcf_c
  "moog VCF: type is 1 (lpf), 2 (hpf) or 3 (bpf)"
  (lambda (type)
    (let ((x 0.0)
          (y1 0.0)
          (y2 0.0)
          (y3 0.0)
          (y4 0.0)
	  (_x 0.0)
          (_y1 0.0)
          (_y2 0.0)
          (_y3 0.0))
      (lambda (in cutoff resonance)
	(let ((f (* 1.75 (/ cutoff SR)))
              ;;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* resonance scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* _x  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* _y1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* _y2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* _y3 p) (* -1.0 k y4)))
	  (set! _x x) (set! _y1 y1) (set! _y2 y2) (set! _y3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
	  ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
	  (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))

(if *build-multi-chan*
    (bind-func vcf_mc_c
      (lambda (type:i64 channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf_c type)))
	  (lambda (chan x freq resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq resonance)))))))

;; FIR filters



;;;;;;;;;;;;
;; delays ;;
;;;;;;;;;;;;

;; These delays are meant to be 'user-facing', in particular they are
;; metronome-aware. All delay arguments are doubles and represent a
;; delay time in beats (at the current tempo)



;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c
  "IIR comb without interpolation (all delays in beats)"
  (lambda (max_delay)
    (let ((delay max_delay)
          (line:double* (zalloc (dtoi64 max_delay)))
	  (time 0)
          (n 0)
          (out 0.0))
      (lambda (in:double wet feedback)
        (set! n (modulo time delay))
        (set! out (pref line n))
        (set! time (+ time 1))
        (pset! line n (* feedback (+ in out)))
        (+ in (* out wet))))))

(bind-func tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:double* (zalloc max_delay))
	  (taps:i64* (zalloc num_of_taps))
	  (delay max_delay)
	  (time 0))
      (lambda (x:double)
	(let ((y 0.0)
	      (i 0)
	      (n (modulo time delay))
	      (gain (/ 1.0 (i64tod num_of_taps))))
	  (pset! line n x)
	  (dotimes (i num_of_taps)
	    (set! y (+ y (* gain (pref line (modulo (+ (pref taps i) n) delay))))))
	  (set! time (+ time 1))
	  y)))))
