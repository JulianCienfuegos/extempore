;;; dsp.xtm -- digital signal processing library for Extempore

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; A library for signal processing in Extmpore.

;;; Code:

;; set *build-multi-chan* to #f if you don't want to compile
;; multichannel extensions
(if (not (defined? '*build-multi-chan*))
    (define *build-multi-chan* #t))

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE double (integer->real *au:samplerate*))
           (bind-val SR double (integer->real *au:samplerate*))))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [double,double,double,double,double*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" SR)))

(print_audio_state)

;; default (silent) audio callback
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))

;;;;;;;;;;;;;;;
;; Utilities ;;
;;;;;;;;;;;;;;;

;;  metronome setup stuff

(bind-val METRO-TEMPO double 120.0)

(bind-func secs2beats
  (lambda (seconds)
    (/ (* METRO-TEMPO seconds) 60.0)))

(bind-func beats2secs
  (lambda (beats)
    (* (/ beats METRO-TEMPO) 60.0)))

(bind-func midi2frq
  (lambda (pitch)
    (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0)))))

(bind-func frq2midi
  (lambda (freq)
    (+ (* 12.0 (log2 (/ freq 440.0))) 69.0)))

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func dsp_randn
  (let ((phase 0))
    (lambda ()
      (let ((u1 (random))
	    (u2 (random))
	    (v1 (- (* 2.0 u1) 1.0))
	    (v2 (- (* 2.0 u2) 1.0))
	    (s (+ (* v1 v1) (* v2 v2))))
	(if (= phase 0)
	    (if (or (> s 1.0) (= s 0.0) (= s 1.0))
		(dsp_randn)
		(* v1 (sqrt (/ (* -2.0 (log s)) s))))
	    (begin (set! phase (- 1 phase))
		   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

;; computationally efficient sin function
;; x values must fall within the range -PI ... PI
(bind-func _sin
  "efficient sin function (arg must be in range [-pi,pi])"
  (let ((p 0.225) ; :_abuf* (alloc))
	(b (/ 4.0 PI))
	(c (/ -4.0 (* PI PI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
	(+ (* p (- (* y (fabs y)) y)) y)))))

;;;;;;;;;;;;
;;  UGens ;;
;;;;;;;;;;;;

;; In idiomatic Extempore DSP, closures are used as the basic building
;; blocks of the signal chain, or unit generators (ugens). These ugen
;; closures are stateful, and are called repeatedly (usually at the
;; audio samplerate) to yield successive values which form their
;; output.
;;
;; Any function which returns a closure should have the suffix _c
;;
;; The most basic ugen is a sin oscillator, which is created using the
;; function osc_c. osc_c takes one argument (the starting phase of the
;; returned closure) and returns a closure which takes two arguments
;; (the frequency and amplitude of the oscillator). There are also
;; other oscillators, including square waves, triangle waves, and
;; white and pink noise.

;; basic impulse (dirac delta) function

(bind-func dirac_c
  "returns an impulse response closure (offset in samples)"
  (lambda (offset)
    (let ((n 0))
      (lambda ()
        (if (= n offset)
            (begin (set! n (+ n 1)) 1.0)
            (begin (set! n (+ n 1)) 0.0))))))

(if *build-multi-chan*
    (bind-func dirac_mc_c
      (lambda (offset)
        (let ((val 0.0)
	      (impulse (dirac_c offset)))
	  (lambda (chan)
	    (if (< chan 1.0) (set! val (impulse)))
	    val)))))

(bind-func heaviside_c
  "returns a heaviside step function ugen closure"
  (lambda (offset)
    (let ((n 0))
      (lambda ()
        (if (< n offset)
            (begin (set! n (+ n 1)) 0.0)
            (begin (set! n (+ n 1)) 1.0))))))

(if *build-multi-chan*
    (bind-func heaviside_mc_c
      (lambda (offset)
        (let ((val 0.0)
	      (heaviside (heaviside_c offset)))
	  (lambda (chan)
	    (if (< chan 1.0) (set! val (heaviside)))
	    val)))))

(bind-func accum_c
  "returns an accumulator closure"
  (lambda ()
    (let ((sum 0.0))
      (lambda (in)
        (set! sum (+ sum in))
        sum))))

;; noise oscillators

(bind-func white_c
  "returns a gaussian white noise ugen closure"
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  "returns a pink noise ugen closure"
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; must be called at audio sample rate
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse_c
  (lambda ()
    (let ((samp 0.0))
      (lambda (apex:double)
        (let ((h (* samp apex)))
          (set! samp (+ samp 1.0))
          (* h (exp (- 1.0 h))))))))

(if *build-multi-chan*
    (bind-func impulse_mc_c
      (lambda ()
        (let ((val 0.0)
	      (impulse (impulse_c)))
	  (lambda (chan apex)
	    (if (< chan 1.0) (set! val (impulse apex)))
	    val)))))

;; uses _sin for efficiency
(bind-func osc_c
  "returns a sin oscillator"
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* TWOPI (/ freq SR))))
	(set! phase (+ phase inc))
	(if (> phase PI) (set! phase (- phase TWOPI)))
	(* amp (_sin phase))))))

(if *build-multi-chan*
    (bind-func osc_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (osc (osc_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (osc amp freq)))
	    val)))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_c
  "returns a square wave ugen closure"
  (lambda (phase)
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
        (* amp (tanh (* n (osc 1.0 freq))))))))

;; square oscillator multichannel
(if *build-multi-chan*
    (bind-func square_mc_c
      (lambda (phase)
	(let ((sqr (square_c phase))
	      (val 0.0))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! val (sqr amp freq n)))
	    val)))))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_c
  "returns a triangle wave ugen closure"
  (lambda (phase)
    (let ((osc (osc_c phase))
          (old 0.0)
          (new 0.0)
          (leak 0.9))
      (lambda (amp freq n)
        (set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

(if *build-multi-chan*
    (bind-func triangle_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (tri (triangle_c phase)))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! val (tri amp freq n)))
	    val)))))

;; pulse wave oscillator - useful for pulse width modulation
(bind-func pulse_c
  "returns a pulse wave ugen closure (duty [0.0,1.0])"
  (let ()
    (lambda (phase)
      (lambda (amp freq duty)
        (let ((inc (/ freq SR)))
          (set! phase (+ phase inc))
          (if (> phase 1.0) (set! phase (- phase 1.0)))
          (if (< phase duty) amp (* -1.0 amp)))))))

(if *build-multi-chan*
    (bind-func rect_mc_c
      (let ()
        (lambda (phase)
          (let ((val 0.0)
                (pulse (pulse_c phase)))
            (lambda (chan amp freq duty)
              (if (< chan 1.0) (set! val (pulse amp freq duty)))
              val))))))

;; saw oscillator
(bind-func saw_c
  "returns a saw ugen closure"
  (lambda (phase)
    (let ((dp 1.0)
	  (x 0.0)
	  (leak 0.995)
	  (saw 0.0))
      (lambda (amp freq)
	(let* ((qmax (* 0.5 (/ SR freq)))
	       (dc (/ -0.498 qmax)))
	  (set! phase (+ phase dp))
	  (if (< phase 0.0)
	      (begin (set! phase (- 0.0 phase))
		     (set! dp (- 0.0 dp)))
	      (if (> phase qmax)
		  (begin (set! phase (+ qmax (- qmax phase)))
			 (set! dp (- 0.0 dp)))))
	  (set! x (* PI phase))
	  (if (< x 0.000001) (set! x 0.00001))
	  (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
	  (* amp saw))))))

;; saw oscillator
(if *build-multi-chan*
    (bind-func saw_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (saw (saw_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (saw amp freq)))
	    val)))))

;; ugens for returning straight lines
;; useful for controlling other paramaters
(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:double end:double dur:double)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (inc)
          (set! time (+ time inc))
          (+ (* m time) c))))))

(if *build-multi-chan*
    (bind-func linear_mc_c
      (let ((time 0.0))
        (lambda (start:double end:double dur:double)
          (let* ((m (/ (- end start) dur))
                 (c (- end (* m dur))))
            (lambda (chan inc)
              (if (< chan 0.5)
                  (set! time (+ time inc)))
              (+ (* m time) c)))))))

;;;;;;;;
;; FX ;;
;;;;;;;;

;; Basically, this means anything which takes an input as well as an
;; output.

(bind-func hard_clip
  (lambda (in:double up_lim low_lim)
    (if (< in low_lim) low_lim
	(if (> in up_lim) up_lim
	    in))))

(bind-func hard_limiter_c
  "returns a hard limiter closure"
  (lambda (up_lim low_lim)
    (lambda (in)
      (hard_clip in up_lim low_lim))))

(bind-func soft_limiter_c
  "softly limit input value into range [-1,1]"
  (lambda (in)
    (tanh in)))

(bind-func waveshape
  (lambda (in distortion)
    (* in
       (/ (+ distortion (fabs in))
          (+ (* in in)
             (* (- distortion 1.0) (fabs in))
             1.0)))))

;; distortion
;; can cascade several of these for more overdrive
(bind-func distortion
  (lambda (in gain)
    (tanh (* in gain)))) 

(bind-func circular_buffer_c
  (lambda (size)
    (let ((buffer:double* (zalloc size))
          (buf_pos 0))
      (lambda (in)
        (let ((out (pref buffer buf_pos)))
          (pset! buffer buf_pos in)
          (set! buf_pos (modulo (+ buf_pos 1) size))
          out)))))

(if *build-multi-chan*
    (bind-func circular_buffer_mc_c
      (lambda (channels:i64 size)
        (let ((val 0.0)
	      (buffers:[double,double]** (zalloc channels))
              (i 0))
	  (dotimes (i channels) (pset! buffers i (circular_buffer_c size)))
	  (lambda (chan in)
	    ((pref buffers (dtoi64 chan)) in))))))


;; simple 'lookahead' compressor
;; introduces a delay of N samples


;;;;;;;;;;;;;
;; filters ;;
;;;;;;;;;;;;;

;; bi-quad IIR filters these filters are all computationally cheap,
;; but there may be stability issues as the resonance parameter is
;; pushed near it's limits

(bind-func allpass_c
  (lambda (delay)
    (let ((_delay (dtoi64 delay))
          (inline:double* (zalloc _delay))
	  (outline:double* (zalloc _delay))
	  (time 0))
      (lambda (in feedback)
	(let* ((n (modulo time _delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (out (+ (* -1.0 feedback in)
                       dx
                       (* feedback dy))))
	  (pset! inline n in)
	  (pset! outline n out)
	  (set! time (+ time 1))
	  out)))))

(if *build-multi-chan*
    (bind-func allpass_mc_c
      (lambda (channels:i64 delay)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (allpass_c delay)))
	  (lambda (chan in wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in wet)))))))

;; biquad low-pass filter
(bind-func lpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_cutoff 0.0)
	   (_resonance 0.0))
      (lambda (in cutoff resonance)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> resonance _resonance))
	    (let* ((omega (* TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 resonance))))
	      (set! _cutoff cutoff)
	      (set! _resonance resonance)
	      (set! b0 (/ (- 1.0 coso) 2.0))
	      (set! b1 (- 1.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func lpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lpf_c)))
	  (lambda (chan in cutoff resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff resonance)))))))

;; biquad high-pass filter
(bind-func hpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_resonance 0.0)
	   (_cutoff 0.0))
      (lambda (in cutoff resonance)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> resonance _resonance))
	    (let* ((omega (* TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 resonance))))
	      (set! _cutoff cutoff)
	      (set! _resonance resonance)
	      (set! b0 (/ (+ 1.0 coso) 2.0))
	      (set! b1 (* -1.0 (+ 1.0 coso)))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func hpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hpf_c)))
	  (lambda (chan in cutoff resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff resonance)))))))

;; biquad band-pass filter
(bind-func bpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_cutoff 0.0)
	   (_bandwidth 0.0))
      ;; bandwidth in octaves
      (lambda (in cutoff bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> cutoff _cutoff)
		(<> bandwidth _bandwidth))
	    (let* ((omega (* 1.0 TWOPI (/ cutoff SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! _cutoff cutoff)
	      (set! _bandwidth bandwidth)
	      (set! b0 alpha)
	      (set! b1 0.0)
	      (set! b2 (* -1.0 b0))
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func bpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (bpf_c)))
	  (lambda (chan in cutoff bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in cutoff bandwidth)))))))

(bind-func notch_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (_freq 0.0)
	   (_bandwidth 0.0))
      ;; bandwidth in octaves
      (lambda (in freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 1.0)
	      (set! b1 (* -2.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 b1)
	      (set! a2 (- 1.0 alpha))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func notch_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (notch_c)))
	  (lambda (chan in freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in freq bandwidth)))))))

;; biquad peaking band EQ filter
(bind-func peak_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
	   (_db_gain 0.0)
	   (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino)))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (+ 1.0 (* alpha A)))
	      (set! b1 (* -2.0 coso))
	      (set! b2 (- 1.0 (* alpha A)))
	      (set! a0 (+ 1.0 (/ alpha A)))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 (/ alpha A)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func peak_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (peak_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))


;; biquad low-shelf filter
(bind-func lsf_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
           (_db_gain 0.0)
           (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if args change, re-calculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino))))
                   (beta (sqrt (+ A A))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (* A (+ (- (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! b1 (* 2.0 A (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! b2 (* A (- (- (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! a0 (+ (+ A 1.0)
                          (* (- A 1.0) coso)
                          (* beta sino)))
	      (set! a1 (* -2.0 (+ (- A 1.0) (* (+ A 1.0) coso))))
	      (set! a2 (- (+ (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func lsf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lsf_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))


;; biquad high-shelf filter
(bind-func hsf_c
  (lambda ()
    (let* ((x1 0.0) (x2 0.0)
           (y1 0.0) (y2 0.0)
           (b0 0.0) (b1 0.0) (b2 0.0)
           (a0 0.0) (a1 0.0) (a2 0.0)
           (_db_gain 0.0)
           (_freq 0.0)
	   (_bandwidth 0.0))
      (lambda (in db_gain freq bandwidth)
	;; if args change, re-calculate coefficients
	(if (or (<> db_gain _db_gain)
                (<> freq _freq)
		(<> bandwidth _bandwidth))
	    (let* ((A (pow 10.0 (/ db_gain 40.0)))
                   (omega (* TWOPI (/ freq SR)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (/ (* (/ LN2 2.0) bandwidth omega) sino))))
                   (beta (sqrt (+ A A))))
	      (set! _db_gain db_gain)
	      (set! _freq freq)
	      (set! _bandwidth bandwidth)
	      (set! b0 (* A (+ (+ (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! b1 (* -2.0 A (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! b2 (* A (- (+ (+ A 1.0)
                                  (* (- A 1.0) coso))
                               (* beta sino))))
	      (set! a0 (+ (- (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))
	      (set! a1 (* 2.0 (- (- A 1.0) (* (+ A 1.0) coso))))
	      (set! a2 (- (- (+ A 1.0)
                             (* (- A 1.0) coso))
                          (* beta sino)))))
	(let ((out (- (+ (* (/ b0 a0) in)
                         (* (/ b1 a0) x1)
                         (* (/ b2 a0) x2))
                      (* (/ a1 a0) y1)
                      (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 out)
	  (set! x2 x1)
	  (set! x1 in)
	  out)))))

(if *build-multi-chan*
    (bind-func hsf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hsf_c)))
	  (lambda (chan in gain_db freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f in gain_db freq bandwidth)))))))

;; a moog-style voltage-controlled filter

(bind-func vcf_c
  "moog VCF: type is 1 (lpf), 2 (hpf) or 3 (bpf)"
  (lambda (type)
    (let ((x 0.0)
          (y1 0.0)
          (y2 0.0)
          (y3 0.0)
          (y4 0.0)
	  (_x 0.0)
          (_y1 0.0)
          (_y2 0.0)
          (_y3 0.0))
      (lambda (in cutoff resonance)
	(let ((f (* 1.75 (/ cutoff SR)))
              ;;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* resonance scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* _x  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* _y1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* _y2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* _y3 p) (* -1.0 k y4)))
	  (set! _x x) (set! _y1 y1) (set! _y2 y2) (set! _y3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
	  ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
	  (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))

(if *build-multi-chan*
    (bind-func vcf_mc_c
      (lambda (type:i64 channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf_c type)))
	  (lambda (chan x freq resonance)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq resonance)))))))

;; FIR filters



;;;;;;;;;;;;
;; delays ;;
;;;;;;;;;;;;

;; These delays are meant to be 'user-facing', in particular they are
;; metronome-aware. All delay arguments are doubles and represent a
;; delay time in beats (at the current tempo)

(bind-func del_c
  "simple, efficient delay (no resizing, no bounds checks)"
  (lambda (delay)
    (let ((line:double* (zalloc delay))
          (line_idx 0)
          (out 0.0))
      (lambda (in:double wet feedback)
        (set! out (pref line line_idx))
        (pset! line line_idx (* feedback (+ in out)))
        (set! line_idx (+ 1 (modulo line_idx delay)))
        (+ in (* out wet))))))

(if *build-multi-chan*
    (bind-func del_mc_c
      (lambda (nchan:i64 delay)
        (let ((dlines:[double,double,double,double]** (alloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! dlines i (del_c delay)))
          (lambda (chan in wet feedback)
            ((pref dlines (dtoi64 chan)) in wet feedback))))))

;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c
  "a delay effect (all delays in beats)"
  (lambda (max_delay)
    (let ((delay max_delay)
          (_delay 0.0)
          (line_length (dtoi64 (* (beats2secs max_delay) SR)))
          ;; allocate more memory, in case the tempo slows down
          (line_overallocation_factor 2)
          (line:double* (zalloc (* 2 line_length)))
          (line_idx 0)
          (out 0.0))
      (lambda (in:double wet feedback)
        (if (<> _delay delay)
            (if (> (/ delay max_delay) (i64tod line_overallocation_factor))
                (begin (printf "Error: delay exceeding initial buffer length!\n")
                       0.0)
                (begin (set! line_length (dtoi64 (* (beats2secs delay) SR)))
                       (set! _delay delay))))
        (set! out (pref line line_idx))
        (pset! line line_idx (* feedback (+ in out)))
        (set! line_idx (+ 1 (modulo line_idx line_length)))
        (+ in (* out wet))))))

(if *build-multi-chan*
    (bind-func delay_mc_c
      (lambda (nchan:i64 max_delay)
        (let ((dlines:[double,double,double,double]** (alloc nchan))
	      (i:i64 0))
          (dotimes (i nchan) (pset! dlines i (delay_c max_delay)))
          (lambda (chan in wet feedback)
            ((pref dlines (dtoi64 chan)) in wet feedback))))))

;; (bind-func tap_delay_c
;;   "a tap delay effect (tap locations in beats)"
;;   (lambda (max_delay num_taps)
;;     (let ((delay max_delay)
;;           (_delay 0.0)
;;           (line_length (dtoi64 (* (beats2secs max_delay) SR)))
;;           ;; allocate more memory, in case the tempo slows down
;;           (line_overallocation_factor 2)
;;           (line:double* (zalloc (* 2 line_length)))
;;           (line_idx 0)
;;           (taps:double* (zalloc num_taps))
;;           (out 0.0))
;;       (lambda (in:double wet feedback)
;;         (if (<> _delay delay)
;;             (if (> (/ delay max_delay) (i64tod line_overallocation_factor))
;;                 (begin (printf "Error: delay exceeding initial buffer length!\n")
;;                        0.0)
;;                 (begin (set! line_length (dtoi64 (* (beats2secs delay) SR)))
;;                        (set! _delay delay))))
;;         (let ((y 0.0)
;; 	      (i 0)
;; 	      (n (modulo time delay))
;; 	      (gain (/ 1.0 (i64tod num_of_taps))))
;; 	  (pset! line n x)
;;           (set! out (pref line line_idx))
;;           (pset! line line_idx (* feedback (+ in out)))
;;           (set! line_idx (+ 1 (modulo line_idx line_length)))
;;           (+ in (* out wet)))))))

;; (bind-func tap_delay_c
;;   (lambda (max_delay num_of_taps)
;;     (let ((line:double* (zalloc max_delay))
;; 	  (taps:i64* (zalloc num_of_taps))
;; 	  (delay max_delay)
;; 	  (time 0))
;;       (lambda (x:double)
;; 	(let ((y 0.0)
;; 	      (i 0)
;; 	      (n (modulo time delay))
;; 	      (gain (/ 1.0 (i64tod num_of_taps))))
;; 	  (pset! line n x)
;; 	  (dotimes (i num_of_taps)
;; 	    (set! y (+ y (* gain (pref line (modulo (+ (pref taps i) n) delay))))))
;; 	  (set! time (+ time 1))
;; 	  y)))))

(bind-func comb_c
  "IIR comb with interpolation"
  (lambda (max_delay)
    (let ((maxdelay (dtoi64 max_delay))
          (line:double* (zalloc maxdelay))
	  (in_head 0)
	  (out_head 0)
	  (_delay max_delay)
	  (alpha 0.0)
	  (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (in:double delay:double wet feedback)
	(if (<> delay _delay)
	    (begin (set! _delay delay)
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ maxdelay in_head)
				     (dtoi64 delay)))))
	(set! ih (modulo in_head maxdelay))
	(set! oh (modulo out_head maxdelay))
	(set! delayed1 (pref line oh))
	(set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
	(set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
	;;(set! y (+ (* in in) (* out delayed)))
        (pset! line ih (* feedback (+ in delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ in (* delayed wet))))))


(if *build-multi-chan*
    (bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
	  (lambda (chan in delay wet feedback)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f in delay wet feedback)))))))


;; flanger
(bind-func flanger_c
  (lambda (delay mod_phase mod_range mod_rate)
    (let ((comb (comb_c (+ delay mod_range)))
	  (mod (osc_c mod_phase)))
      (lambda (in:double wet feedback)
	(comb in (+ delay (mod mod_range mod_rate)) wet feedback)))))


(if *build-multi-chan*
    (bind-func flanger_mc_c
      (lambda (channels:i64 delay mod_phase mod_range mod_rate)
	(let ((comb (comb_mc_c channels (+ delay mod_range)))
	      (mod (osc_mc_c mod_phase))
	      (i:i64 0))
	  (lambda (chan in wet feedback)
	    (comb chan in (+ delay (mod chan mod_range mod_rate)) wet feedback))))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay 700.0)
	  (range 200.0)
	  (rate 0.1)
	  (comb1 (comb_c (+ delay range)))
	  (comb2 (comb_c (+ delay range)))
	  (comb3 (comb_c (+ delay range)))
	  (mrng1 range)
	  (mrng2 (* (random) range))
	  (mrng3 (* (random) range))
	  (mrte1 rate)
	  (mrte2 (* rate 1.372))
	  (mrte3 (* rate 0.792))
	  (dly1 delay)
	  (dly2 (* (random) delay))
	  (dly3 (* (random) delay))
	  (mod1 (osc_c phase))
	  (mod2 (osc_c phase))
	  (mod3 (osc_c phase)))
      (lambda (in:double wet fb)
	(+ (comb1 in (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
	   (comb2 in (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
	   (comb3 in (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(if *build-multi-chan*
    (bind-func chorus_mc_c
      (lambda (channels:i64 phase)
	(let ((dlines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (chorus_c phase)))
	  (lambda (chan in wet fb)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f in wet fb)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; instrument utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; used in libs/core/instruments.xtm

(bind-func line_c
  (lambda (x1:double y1:double x2 y2)
    (let* ((m (if (= 0.0 (- x2 x1))
		  0.0
		  (/ (- y2 y1) (- x2 x1))))
	   (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func envelope_segments
  (lambda (points:double* num_of_points:i64)
    (let ((lines:[double,double]** (zalloc num_of_points))
	  (k 0))
      (dotimes (k num_of_points)
	(let* ((idx (* k 2))
	       (x1 (pref points (+ idx 0)))
	       (y1 (pref points (+ idx 1)))
	       (x2 (pref points (+ idx 2)))
	       (y2 (pref points (+ idx 3))))
	  (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:double* num_of_points)
    (let ((klines:[double,double]** (envelope_segments points num_of_points))
	  (line_length num_of_points))
      (lambda (time)
	(let ((res -1.0)
	      (k:i64 0))
	  (dotimes (k num_of_points)
	    (let ((line (pref klines k))
		  (time_point (pref points (* k 2))))
	      (if (or (= time time_point)
		      (< time_point time))
		  (set! res (line time)))))
	  res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let* ((points 6)
	   (data:double* (zalloc (* points 2))))
      (pset! data 0 start_time)
      (pset! data 1 0.0)
      (pset! data 2 (+ start_time atk_dur)) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (+ start_time atk_dur dky_dur))
      (pset! data 5 sus_amp)
      (pset! data 6 (+ start_time atk_dur dky_dur sus_dur))
      (pset! data 7 sus_amp)
      (pset! data 8 (+ start_time atk_dur dky_dur sus_dur rel_dur))
      (pset! data 9 0.0)
      (pset! data 10 (+ start_time atk_dur dky_dur sus_dur rel_dur 1.0)) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
	(lambda (time:double)
	  (f time))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:double atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let ((val (if (> (+ atk_dur dky_dur) 1.0) 0.0 peak_amp))
	  (t1 atk_dur)
	  (t2 (+ atk_dur dky_dur))
	  (t3 (+ atk_dur dky_dur sus_dur))
	  (t4 (+ atk_dur dky_dur sus_dur rel_dur))
	  (inc1 (/ peak_amp atk_dur))
	  (inc2 (* -1.0 (/ (- peak_amp sus_amp) dky_dur)))
	  (inc3 (* -1.0 (/ sus_amp rel_dur))))
      (lambda (time:double chan)
	(if (< chan 1.0)
	    (cond ((> time t4) (set! val 0.0))
		  ((> time t3) (set! val (+ val inc3)))
		  ((> time t2) val) ;; sustain (don't do anything with val)
		  ((> time t1) (set! val (+ val inc2)))
		  ((> time 0) (set! val (+ val inc1)))
		  (else (set! val 0.0))))
	val))))

(bind-func hermite_interp
  (lambda (fractional y1:double x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
	  (v (- x0 x1))
	  (w (+ c v))
	  (a (+ w v (* (- x2 x0) 0.5)))
	  (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))

;; linear fade closure
(bind-func fade_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (/ freq SAMPLERATE)))
	(if (> phase 1.0)
            amp
            (begin (set! phase (+ phase inc))
                   (* phase amp)))))))

(if *build-multi-chan*
    (bind-func fade_mc_c
      (lambda (phase)
        (let ((val 0.0)
	      (fade (fade_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! val (fade amp freq)))
	    val)))))
