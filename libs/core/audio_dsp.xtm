;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; A library for audio & dsp processing in Extmpore.

;;; Code:

;; set *build-multi-chan* to #t to compile multichannel extensions
(if (not (defined? '*build-multi-chan*))
    (define *build-multi-chan* #f))

;;;;;;;;;;;;;;;;;;;
;; DSP utilities ;;
;;;;;;;;;;;;;;;;;;;

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE double (integer->real *au:samplerate*))
           (bind-val SR double (integer->real *au:samplerate*))))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [double,double,double,double,double*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" SAMPLERATE)))

(print_audio_state)

;; default (silent) audio callback
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html


;;;;;;;;;;;;;;;;;;;;;;;
;; Extempore filters ;;
;;;;;;;;;;;;;;;;;;;;;;;

;; allpass
(bind-func allpass_old_c
  (lambda (delay)
    (let ((inline:double* (zalloc delay))
	  (outline:double* (zalloc delay))
	  (time 0)
	  (g 0.9))
      (lambda (x)
	(let* ((n (modulo time delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (y (+ (* -1.0 g x)
		     dx
		     (* g dy))))
	  (pset! inline n x)
	  (pset! outline n y)
	  (set! time (+ time 1))
	  y)))))

;; allpass

;; BiQuad coefficient formulae from
;; Audio EQ Cookbook Robert Bristow-Johnson
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt




;; FIR filters

;; components



(bind-func fir_c
  (lambda (order:i64 coef:double*)
    ))

;; Hilbert transform filter

(bind-func hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:double* (alloc n))
          (x_n:double* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (i64tod i) PI))
                  (pow (sin (/ (* (i64tod i) PI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (modulo (+ i x_ptr (- n 1)) n))))))
          (modulo (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))

;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf_old_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
	  (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in cutoff res)
	(let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* res scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

	  (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
	  y4)))))


;;
;; moog VCF variation 1
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf1_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
	  (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in cutoff res)
	(let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
	      (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))
	  (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
                       (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667))) ;; clipping
          (set! b0 in)
          b4)))))

;;
;; moog VCF variation 2
;;
;; from Stilson/Smith CCRMA
;;


;;
;; moog VCF variation 3
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf3_c
  (lambda (type)
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
	  (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in cutoff res)
	(let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
	      (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))
	  (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
                       (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667)))
          ;;(set! b4 (- b4 (* b4 b4 0.25))) ;; clipping
          (set! b0 in)
          (if (= type 2) (- b0 b4) ;; high pass
              (if (= type 3) (* 3.0 (- b3 b4))
                  b4)))))))


;; State Variable Filter adapted from
;; http://www.musicdsp.org/archive.php?classid=3#142 (it is possible
;; to get all the hp, lp, bp and notch output values in one function,
;; however they are currently provided in separate functions)

(if (not (llvm:get-globalvar "SVF_LOWPASS"))
    (bind-val SVF_LOWPASS i64 1))
(if (not (llvm:get-globalvar "SVF_HIGHPASS"))
    (bind-val SVF_HIGHPASS i64 2))
(if (not (llvm:get-globalvar "SVF_BANDPASS"))
    (bind-val SVF_BANDPASS i64 3))
(if (not (llvm:get-globalvar "SVF_NOTCH"))
    (bind-val SVF_NOTCH i64 4))
(if (not (llvm:get-globalvar "SVF_PEAK"))
    (bind-val SVF_PEAK i64 5))

(bind-func min2d
  (lambda (a:double b)
    (if (< a b) a b)))

(bind-func svf_c
  "returns a state variable filter closure"
  (lambda (type)
    ;; old values
    (let ((cutoff_ 0.0)
          (resonance_ 0.0)
          (drive 0.0)
          (freq 0.0)
          (damp 0.0)
          (notch 0.0)
          (low 0.0)
          (high 0.0)
          (band 0.0)
          (peak 0.0)
          (out 0.0))
      (lambda (in cutoff resonance)
        ;; recalculate some values if cutoff or resonance have changed
        (if (or (<> cutoff cutoff_)
                (<> resonance resonance_))
            (begin
              (set! cutoff_ cutoff)
              (set! resonance_ resonance)
              (set! freq (* 2.0 (sin (* PI (min2d 0.25 (/ cutoff (* SAMPLERATE 2.0)))))))
              (set! damp (min2d (* 2.0 (- 1.0 (pow resonance 0.25)))
                                (min2d 2.0 (- (/ 2.0 freq) (* freq 0.5)))))))
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (* 0.5 (if (= type SVF_LOWPASS)
                             low
                             (if (= type SVF_HIGHPASS)
                                 high
                                 (if (= type SVF_BANDPASS)
                                     band
                                     (if (= type SVF_NOTCH)
                                         notch
                                         (if (= type SVF_PEAK)
                                             peak
                                             0.0)))))))
        ;; now do it all again (because it's oversampled for
        ;; stability)
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (+ out (* 0.5 (if (= type SVF_LOWPASS)
                                    low
                                    (if (= type SVF_HIGHPASS)
                                        high
                                        (if (= type SVF_BANDPASS)
                                            band
                                            (if (= type SVF_NOTCH)
                                                notch
                                                (if (= type SVF_PEAK)
                                                    peak
                                                    0.0))))))))))))

;;;;;;;;;;;;;;;;;;
;; Extempore FX ;;
;;;;;;;;;;;;;;;;;;

;; should have args (in wet feedback)? Hard to come up with a
;; consistent arg list for this bunch, probably not worth bothering

;; more efficient than comb if you
;; don't need variable length
(bind-func delay_old_c
  "IIR comb without interpolation (old version)"
  (lambda (max_delay)
    (let ((line:double* (zalloc max_delay))
	  (time 0)
	  (delay max_delay)
	  (in 1.0)
	  (out 0.5))
      (lambda (x:double)
	(let* ((n (modulo time delay))
	       (delayed (pref line n))
	       (y (+ (* in x) (* out delayed))))
	  (pset! line n y)
	  (set! time (+ time 1))
	  y)))))


(if *build-multi-chan*
    (bind-func delay_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
	  (lambda (chan x wet feedback)
	    ((pref dlines (dtoi32 chan)) x wet feedback))))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
;;
;; offset is for metro 'get-mark offset
(bind-func delay_t_c
  (lambda (max_delay offset)
    (let ((delay (dtoi64 max_delay))
          (line:double* (zalloc delay))
	  ;; (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:double time wet feedback)
        (set! n (modulo (dtoi64 (- time offset)) delay))
        (set! y (pref line n))
        ;;(set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
    (bind-func delay_t_mc_c
      (lambda (channels:i64 max_delay offset)
	(let ((dlines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_t_c max_delay offset)))
	  (lambda (chan x time wet feedback)
	    ((pref dlines (dtoi32 chan)) x time wet feedback))))))

(if *build-multi-chan*
    (bind-func delay_t_st_c
      (lambda (d1 d2 offset)
	(let ((dlines:[double,double,double,double,double]** (alloc 2))
	      (i:i64 0))
	  (pset! dlines 0 (delay_t_c d1 offset))
	  (pset! dlines 1 (delay_t_c d2 offset))
	  (lambda (chan x time wet feedback)
	    ((pref dlines (dtoi32 chan)) x time wet feedback))))))


(bind-func comb_old_c
  "IIR comb with interpolation (old version)"
  (lambda (max_delay)
    (let ((line:double* (zalloc max_delay))
	  (in_head 0)
	  (out_head 0)
	  (delay_ (i64tod max_delay))
	  ;;(delay (i64tod max_delay))
	  (alpha 0.0)
	  (om_alpha 1.0)
	  (in 1.0)
	  (i 0)
	  (out 0.5))
      (dotimes (i max_delay) (pset! line i 0.0))
      (lambda (x:double delay:double)
	(if (<> delay delay_)
	    (begin (set! delay_ delay)
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ max_delay in_head)
				     (dtoi64 delay)))))
	(let* ((ih:i64 (modulo in_head max_delay))
	       (oh:i64 (modulo out_head max_delay))
	       (delayed1 (pref line oh))
	       (delayed2 (pref line (modulo (+ oh 1) max_delay)))
	       (delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
	       (y (+ (* in x) (* out delayed))))
	  (pset! line ih y)
	  (set! in_head (+ ih 1))
	  (set! out_head (+ oh 1))
	  y)))))


;; iir comb with interpolation
(bind-func comb_c
  "IIR comb with interpolation"
  (lambda (max_delay)
    (let ((maxdelay (dtoi64 max_delay))
          (line:double* (zalloc maxdelay))
	  (in_head 0)
	  (out_head 0)
	  (delay_ max_delay)
	  (alpha 0.0)
	  (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (x:double delay:double wet feedback)
	(if (<> delay delay_)
	    (begin (set! delay_ delay)
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ maxdelay in_head)
				     (dtoi64 delay)))))
	(set! ih (modulo in_head maxdelay))
	(set! oh (modulo out_head maxdelay))
	(set! delayed1 (pref line oh))
	(set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
	(set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
	;;(set! y (+ (* in x) (* out delayed)))
        (pset! line ih (* feedback (+ x delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ x (* delayed wet))))))


(if *build-multi-chan*
    (bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
	  (lambda (chan x delay wet feedback)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f x delay wet feedback)))))))


;; flanger
(bind-func flanger_c
  (lambda (delay mod_phase mod_range mod_rate)
    (let ((comb (comb_c (+ delay mod_range)))
	  (mod (osc_c mod_phase)))
      (lambda (x:double wet feedback)
	(comb x (+ delay (mod mod_range mod_rate)) wet feedback)))))


(if *build-multi-chan*
    (bind-func flanger_mc_c
      (lambda (channels:i64 delay mod_phase mod_range mod_rate)
	(let ((comb (comb_mc_c channels (+ delay mod_range)))
	      (mod (osc_mc_c mod_phase))
	      (i:i64 0))
	  (lambda (chan x wet feedback)
	    (comb chan x (+ delay (mod chan mod_range mod_rate)) wet feedback))))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay 700.0)
	  (range 200.0)
	  (rate 0.1)
	  (comb1 (comb_c (+ delay range)))
	  (comb2 (comb_c (+ delay range)))
	  (comb3 (comb_c (+ delay range)))
	  (mrng1 range)
	  (mrng2 (* (random) range))
	  (mrng3 (* (random) range))
	  (mrte1 rate)
	  (mrte2 (* rate 1.372))
	  (mrte3 (* rate 0.792))
	  (dly1 delay)
	  (dly2 (* (random) delay))
	  (dly3 (* (random) delay))
	  (mod1 (osc_c phase))
	  (mod2 (osc_c phase))
	  (mod3 (osc_c phase)))
      (lambda (x:double wet fb)
	(+ (comb1 x (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
	   (comb2 x (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
	   (comb3 x (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(if *build-multi-chan*
    (bind-func chorus_mc_c
      (lambda (channels:i64 phase)
	(let ((dlines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (chorus_c phase)))
	  (lambda (chan x wet fb)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f x wet fb)))))))


;; tap delay

;; a dodgy reverb
;; (bind-func reverb_c
;;   (lambda (size) ; size in ms
;;     (let ((ms (/ SAMPLERATE 1000.0))
;; 	  (wet .25)
;; 	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
;; 	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
;; 	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
;; 	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
;; 	  (ap1 (allpass_c (dtoi64 (* ms size))))
;; 	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
;;       (ap1.g .8)
;;       (ap2.g .8)
;;       (lambda (in)
;; 	(let ((wetin (* in wet)))
;; 	  (+ (* in (- 1.0 wet)) (ap1 (ap2 (+ (dly1 wetin)
;; 					     (dly2 wetin)
;; 					     (dly3 wetin)
;; 					     (dly4 wetin))))))))))

;; a dodgy reverb mk2
(bind-func reverb_old_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_old_c (dtoi64 (* ms (* .192 size)))))
	  (dly2 (delay_old_c (dtoi64 (* ms (* .373 size)))))
	  (dly3 (delay_old_c (dtoi64 (* ms (* .671 size)))))
	  (dly4 (delay_old_c (dtoi64 (* ms (* .712 size)))))
	  (ap1 (allpass_old_c (dtoi64 (* ms size))))
	  (ap3 (allpass_old_c (dtoi64 (* ms (* .929 size)))))
	  (ap2 (allpass_old_c (dtoi64 (* ms (* .329 size))))))
      (ap1.g .8)
      (ap2.g .7)
      (ap3.g .6)
      (lambda (in wet)
	(let ((wetin (* in wet)))
	  (+ (* in (- 1.0 wet))
	     (ap1 (ap2 (ap3 (+ (dly1 wetin)
			       (dly2 wetin)
			       (dly3 wetin)
			       (dly4 wetin)))))))))))


;; a dodgy reverb mk2
(bind-func reverb_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_c (* ms (* .192 size))))
	  (dly2 (delay_c (* ms (* .373 size))))
	  (dly3 (delay_c (* ms (* .671 size))))
	  (dly4 (delay_c (* ms (* .712 size))))
	  (ap1 (allpass_c (* ms size)))
	  (ap3 (allpass_c (* ms (* .929 size))))
	  (ap2 (allpass_c (* ms (* .329 size)))))
      (lambda (in wet fb)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (* .3 (+ (dly1 wetin 1.0 fb)
                                     (dly2 wetin 1.0 fb)
                                     (dly3 wetin 1.0 fb)
                                     (dly4 wetin 1.0 fb)))
                            .8)
                       .7)
                  .6)))))))

(if *build-multi-chan*
    (bind-func reverb_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb_c size)))
	  (lambda (chan x wet fb)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet fb)))))))


;; a dodgy reverb mk2
(bind-func reverb2_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (ap1 (allpass_c (* ms size)))
	  (ap3 (allpass_c (* ms (* .929 size))))
	  (ap2 (allpass_c (* ms (* .329 size)))))
      (lambda (in wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 wetin .8) .7) .6)))))))


(if *build-multi-chan*
    (bind-func reverb2_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb2_c size)))
	  (lambda (chan x wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet)))))))




;; a dodgy bitcrusher
(bind-func crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits)
	(* amp (/ (floor (* in (pow 2. bits)))
		  (pow 2. bits)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func hold3_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in h:double)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))


(if *build-multi-chan*
    (bind-func hold_mc_c
      (lambda (channels:i64)
	(let ((holds:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! holds i (hold3_c)))
	  (lambda (chan x h)
	    (let ((f (pref holds (dtoi32 chan))))
	      (f x h)))))))


;; a dodgy bitcrusher
(bind-func crush
  (lambda (in bits)
    (/ (floor (* in (pow 2. bits)))
       (pow 2. bits))))


;; a dodgy amp distortion
(bind-func distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in)
	(range_limit lim (* -1.0 lim) (* gain in))))))

;; mono in (ignores anything in on channel 2)
;; pan value [0.0-1.0]
(bind-func pan2
  (let ((out 0.0))
    (lambda (x:double chan pan)
      (if (< chan 0.5)
          (begin (set! out x) (* (- 1.0 pan) out))
          (* pan out)))))

;; mono in (ignores all other channels)
;; pan value [0.0-1.0]
(if *build-multi-chan*
    (bind-func pan_mc
      (lambda (channels)
        (let ((v:double 0.0)
              (out:double 0.0))
          (lambda (x:double chan pan)
            (if (< chan 0.5) (set! out x))
            (set! v (fabs (- (* (- channels 1.0) pan) chan)))
            (if (> v 1.0) 0.0
                (* (- 1.0 v) out)))))))


;; simple stereo weights
(bind-func mix2
  (lambda (x:double chan left right)
    (cond ((< chan 0.5) (* x left))
          ((< chan 1.5) (* x right))
          (else 0.0))))

;; simple quad weights
(bind-func mix4
  (lambda (x:double chan c1 c2 c3 c4)
    (cond ((< chan 0.5) (* x c1))
	  ((< chan 1.5) (* x c2))
	  ((< chan 2.5) (* x c3))
	  ((< chan 3.5) (* x c4))
	  (else 0.0))))

;; a four channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (let ((ch (i64tod channels)))
      (lambda (cdat:double* chan:double in:double)
	(if (< chan channels)
	    (* in (pref cdat (dtoi32 chan)))
	    0.0)))))


;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda (drive)
    (let ((drive_minus_1 (- drive 1.0)))
      (lambda (x)
        (let ((absx (fabs x)))
          (/ (* x (+ absx drive))
             (+ (* x x)
                (* drive_minus_1 absx)
                1.0)))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x level character)
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- x q)
                            (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))

;; a repeating hann signal of width
(bind-func hann
  (lambda (time:double width:double repeat:double)
    (* 0.5
       (- 1.0
          (cos (/ (* TWOPI (% time repeat))
                  (- width 1.0)))))))

;; hann
(bind-func hann_c
  "hanning window: (width)"
  (lambda ()
    (let ((cnt -1.0))
      (lambda (width)
        (set! cnt (+ cnt 1.0))
        (* 0.5
           (- 1.0
              (cos (/ (* TWOPI (% cnt width))
                      (- width 1.0)))))))))

(if *build-multi-chan*
    (bind-func hann_mc_c
      (lambda ()
	(let ((h (hann_c))
	      (mem 0.0))
	  (lambda (chan width)
	    (if (< chan 0.5) (set! mem (h width)))
	    mem)))))

;; hann with time
(bind-func hann_t_c
  "hanning window: (time-offset width)"
  (lambda (offset)
    (lambda (time width)
      ;;(set! cnt (+ cnt 1.0))
      (* 0.5
         (- 1.0
            (cos (/ (* TWOPI (% (- time offset) width))
                    (- width 1.0))))))))

(if *build-multi-chan*
    (bind-func hann_t_mc_c
      (lambda (offset)
	(let ((h (hann_t_c offset))
	      (mem 0.0))
	  (lambda (chan time width)
	    (if (< chan 0.5) (set! mem (h time width)))
	    mem)))))

(bind-func hann_e_c
  "hanning window: (width repeat offset)"
  (lambda ()
    (let ((cnt -1.0))
      (lambda (width offset repeat)
        (if (> cnt repeat) (set! cnt -1.0))
        (set! cnt (+ cnt 1.0))
        (if (and (or (> cnt offset) (< offset 0.1))
                 (< cnt (+ width offset)))
            (* 0.5
               (- 1.0
                  (cos (/ (* TWOPI (% (- cnt offset) width))
                          (- width 1.0)))))
            0.0)))))

;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse
  (lambda (time:double apex:double)
    (let ((h (* time apex)))
      (* h (exp (- 1.0 h))))))

(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:double end:double dur:double)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (inc)
          (set! time (+ time inc))
          (+ (* m time) c))))))

(bind-func linear_mc_c
  (let ((time 0.0))
    (lambda (start:double end:double dur:double)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (chan inc)
          (if (< chan 0.5)
              (set! time (+ time inc)))
          (+ (* m time) c))))))

;; straight line & envelope functions
;; these are used in libs/core/instruments.xtm

(bind-func line_c
  (lambda (x1:double y1:double x2 y2)
    (let* ((m (if (= 0.0 (- x2 x1))
		  0.0
		  (/ (- y2 y1) (- x2 x1))))
	   (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func envelope_segments
  (lambda (points:double* num_of_points:i64)
    (let ((lines:[double,double]** (zalloc num_of_points))
	  (k 0))
      (dotimes (k num_of_points)
	(let* ((idx (* k 2))
	       (x1 (pref points (+ idx 0)))
	       (y1 (pref points (+ idx 1)))
	       (x2 (pref points (+ idx 2)))
	       (y2 (pref points (+ idx 3))))
	  (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:double* num_of_points)
    (let ((klines:[double,double]** (envelope_segments points num_of_points))
	  (line_length num_of_points))
      (lambda (time)
	(let ((res -1.0)
	      (k:i64 0))
	  (dotimes (k num_of_points)
	    (let ((line (pref klines k))
		  (time_point (pref points (* k 2))))
	      (if (or (= time time_point)
		      (< time_point time))
		  (set! res (line time)))))
	  res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let* ((points 6)
	   (data:double* (zalloc (* points 2))))
      (pset! data 0 start_time)
      (pset! data 1 0.0)
      (pset! data 2 (+ start_time atk_dur)) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (+ start_time atk_dur dky_dur))
      (pset! data 5 sus_amp)
      (pset! data 6 (+ start_time atk_dur dky_dur sus_dur))
      (pset! data 7 sus_amp)
      (pset! data 8 (+ start_time atk_dur dky_dur sus_dur rel_dur))
      (pset! data 9 0.0)
      (pset! data 10 (+ start_time atk_dur dky_dur sus_dur rel_dur 1.0)) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
	(lambda (time:double)
	  (f time))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:double atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let ((val (if (> (+ atk_dur dky_dur) 1.0) 0.0 peak_amp))
	  (t1 atk_dur)
	  (t2 (+ atk_dur dky_dur))
	  (t3 (+ atk_dur dky_dur sus_dur))
	  (t4 (+ atk_dur dky_dur sus_dur rel_dur))
	  (inc1 (/ peak_amp atk_dur))
	  (inc2 (* -1.0 (/ (- peak_amp sus_amp) dky_dur)))
	  (inc3 (* -1.0 (/ sus_amp rel_dur))))
      (lambda (time:double chan)
	(if (< chan 1.0)
	    (cond ((> time t4) (set! val 0.0))
		  ((> time t3) (set! val (+ val inc3)))
		  ((> time t2) val) ;; sustain (don't do anything with val)
		  ((> time t1) (set! val (+ val inc2)))
		  ((> time 0) (set! val (+ val inc1)))
		  (else (set! val 0.0))))
	val))))

(bind-func hermite_interp
  (lambda (fractional y1:double x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
	  (v (- x0 x1))
	  (w (+ c v))
	  (a (+ w v (* (- x2 x0) 0.5)))
	  (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))

;; linear fade closure
(bind-func fade_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (/ freq SAMPLERATE)))
	(if (> phase 1.0)
            amp
            (begin (set! phase (+ phase inc))
                   (* phase amp)))))))

;;  midi/freq utilities

(bind-func midi2frq
  (lambda (pitch)
    (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0)))))

(bind-func frq2midi
  (lambda (freq)
    (+ (* 12.0 (log2 (/ freq 440.0))) 69.0)))
