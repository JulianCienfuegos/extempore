;;; gl-osx.xtm -- OSX (Core Graphics) GL context management bindings

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libGL

;;; Commentary:

;; 

;;; Code:

;; CGLTypes.h 

;; (sys:load "libs/external/gl2.xtm")

(sys:load-preload-check 'gl-osx)
(define *xtmlib-gl-osx-loaded* #f)

(if (or (not (defined? 'libGL))
        (not libGL))
    (begin (print-with-colors 'red 'default #t
                                  (print "Error"))
           (print ": the OSX OpenGL framework (i.e. libGL) is not loaded, cannot load platform-specific OpenGL extensions.\n")
           (error)))

;; bind-gl-extension: copypasta'd from bind-lib

;; OSX


(bind-val xtgl_get_proc_address [i8*,i8*]*)

(bind-func create_xtgl_get_proc_address
  (lambda (libGL_ptr:i8*)
    (set! xtgl_get_proc_address
          (lambda (name:i8*)
            (if (not (null? libGL_ptr))
                (dlsym libGL_ptr name)
                null)))))

(create_xtgl_get_proc_address libGL)

(bind-func test
  (lambda ()    
    (printf "ptr: %p\n" (xtgl_get_proc_address "glBindFramebuffer"))))


;; ;; GLX

;; (bind-lib libGL glXGetProcAddressARB [i8*,i8*]*)

;; (bind-func xtgl_get_proc_address
;;   (lambda (name:i8*)
;;     (glXGetProcAddressARB name)))

;; ;; wgl

;; (bind-lib libGL wglGetProcAddress [i8*,i8*]*)

;; (bind-func xtgl_get_proc_address
;;   (lambda (name:i8*)
;;     (wglGetProcAddressARB name)))


(define-macro (bind-gl-extension library extension-name type . args)
  `(__dynamic-bind-gl-extension ',library ',extension-name ',type ,@(map (lambda (k) `(quote ,k)) args)))

(define __dynamic-bind-gl-extension
  (lambda (library extension-name type . args)
    (let* ((ctype (cdr (impc:ir:get-type-from-pretty-str (symbol->string type))))
           (calling_convention (if (null? args) "ccc" (symbol->string (car args))))
           (ircode (string-append "declare "
                                  calling_convention
                                  " "
                                   (impc:ir:get-type-str (car ctype))
                                   " @"
                                   (symbol->string extension-name)
                                   "("
                                   (if (null? (cdr ctype))
                                       ""
                                       (apply string-append
                                              (impc:ir:get-type-str (cadr ctype))
                                              (map (lambda (v)
                                                     (string-append "," (impc:ir:get-type-str v)))
                                                   (cddr ctype))))
                                   ") nounwind")))
      (println ircode)
      (if (and (llvm:compile ircode)
               (llvm:bind-global-var (symbol->string extension-name)
                                     (xtgl_get_proc_address (symbol->string extension-name))))
          (impc:compiler:print-lib-binding-details-to-log library extension-name type)
	  (impc:compiler:print-compiler-error (string-append "could not bind!" (symbol->string extension-name)))))))






;; /*
;; ** CGL opaque data.
;; */
(bind-alias CGLContextObj i8*)      ;;  _CGLContextObject
(bind-alias CGLPixelFormatObj i8*)  ;;  _CGLPixelFormatObject
(bind-alias CGLRendererInfoObj i8*) ;;  _CGLRendererInfoObject
(bind-alias CGLPBufferObj i8*)      ;;  _CGLPBufferObject OPENGL_DEPRECATED(10_3, 10_7);
;; (bind-type CGLContextObj <i8*>)      ;;  _CGLContextObject
;; (bind-type CGLPixelFormatObj <i8*>)  ;;  _CGLPixelFormatObject
;; (bind-type CGLRendererInfoObj <i8*>) ;;  _CGLRendererInfoObject
;; (bind-type CGLPBufferObj <i8*>)      ;;  _CGLPBufferObject OPENGL_DEPRECATED(10_3, 10_7);

;; /*
;; ** Attribute names for CGLChoosePixelFormat and CGLDescribePixelFormat.
;; */
(bind-alias CGLPixelFormatAttribute enum)

(bind-val kCGLPFAAllRenderers CGLPixelFormatAttribute 1)                         ;; /* choose from all available renderers          */
(bind-val kCGLPFATripleBuffer CGLPixelFormatAttribute 3)                         ;; /* choose a triple buffered pixel format        */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLPFADoubleBuffer CGLPixelFormatAttribute 5)                         ;; /* choose a double buffered pixel format        */
(bind-val kCGLPFAStereo CGLPixelFormatAttribute 6)                               ;; /* stereo buffering supported                   */
(bind-val kCGLPFAColorSize CGLPixelFormatAttribute 8)                            ;; /* number of color buffer bits                  */
(bind-val kCGLPFAAlphaSize CGLPixelFormatAttribute 11)                           ;; /* number of alpha component bits               */
(bind-val kCGLPFADepthSize CGLPixelFormatAttribute 12)                           ;; /* number of depth buffer bits                  */
(bind-val kCGLPFAStencilSize CGLPixelFormatAttribute 13)                         ;; /* number of stencil buffer bits                */
(bind-val kCGLPFAMinimumPolicy CGLPixelFormatAttribute 51)                       ;; /* never choose smaller buffers than requested  */
(bind-val kCGLPFAMaximumPolicy CGLPixelFormatAttribute 52)                       ;; /* choose largest buffers of type requested     */
(bind-val kCGLPFASampleBuffers CGLPixelFormatAttribute 55)                       ;; /* number of multi sample buffers               */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLPFASamples CGLPixelFormatAttribute 56)                             ;; /* number of samples per multi sample buffer    */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLPFAColorFloat CGLPixelFormatAttribute 58)                          ;; /* color buffers store floating point pixels    */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLPFAMultisample CGLPixelFormatAttribute 59)                         ;; /* choose multisampling                         */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLPFASupersample CGLPixelFormatAttribute 60)                         ;; /* choose supersampling                         */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLPFASampleAlpha CGLPixelFormatAttribute 61)                         ;; /* request alpha filtering                      */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLPFARendererID CGLPixelFormatAttribute 70)                          ;; /* request renderer by ID                       */
(bind-val kCGLPFANoRecovery CGLPixelFormatAttribute 72)                          ;; /* disable all failure recovery systems         */
(bind-val kCGLPFAAccelerated CGLPixelFormatAttribute 73)                         ;; /* choose a hardware accelerated renderer       */
(bind-val kCGLPFAClosestPolicy CGLPixelFormatAttribute 74)                       ;; /* choose the closest color buffer to request   */
(bind-val kCGLPFABackingStore CGLPixelFormatAttribute 76)                        ;; /* back buffer contents are valid after swap    */
(bind-val kCGLPFABackingVolatile CGLPixelFormatAttribute 77)                     ;; /* back buffer contents are volatile after swap */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLPFADisplayMask CGLPixelFormatAttribute 84)                         ;; /* mask limiting supported displays             */
(bind-val kCGLPFAAllowOfflineRenderers CGLPixelFormatAttribute 96)               ;; /* show offline renderers in pixel formats      */ OPENGL_ENUM_AVAILABLE(10_5)
(bind-val kCGLPFAAcceleratedCompute CGLPixelFormatAttribute 97)                  ;; /* choose a hardware accelerated compute device */ OPENGL_ENUM_AVAILABLE(10_6)
(bind-val kCGLPFAOpenGLProfile CGLPixelFormatAttribute 99)                       ;; /* specify an OpenGL Profile to use             */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLPFASupportsAutomaticGraphicsSwitching CGLPixelFormatAttribute 101) ;; /* responds to display changes                  */ OPENGL_ENUM_AVAILABLE(10_8)
(bind-val kCGLPFAVirtualScreenCount CGLPixelFormatAttribute 128)                 ;; /* number of virtual screens in this format     */

;; /* Note: the following attributes are deprecated in Core Profile                    */
(bind-val kCGLPFAAuxBuffers CGLPixelFormatAttribute 7)       ;; /* number of aux buffers                        */
(bind-val kCGLPFAAccumSize CGLPixelFormatAttribute 14)       ;; /* number of accum buffer bits                  */
(bind-val kCGLPFAAuxDepthStencil CGLPixelFormatAttribute 57) ;; /* each aux buffer has its own depth stencil    */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLPFAOffScreen CGLPixelFormatAttribute 53)       ;; OPENGL_ENUM_DEPRECATED(10_0, 10_7)
(bind-val kCGLPFAWindow CGLPixelFormatAttribute 80)          ;; OPENGL_ENUM_DEPRECATED(10_0, 10_9)
(bind-val kCGLPFACompliant CGLPixelFormatAttribute 83)       ;; OPENGL_ENUM_DEPRECATED(10_0, 10_9)
(bind-val kCGLPFAPBuffer CGLPixelFormatAttribute 90)         ;; OPENGL_ENUM_DEPRECATED(10_3, 10_7)
(bind-val kCGLPFARemotePBuffer CGLPixelFormatAttribute 91)   ;; OPENGL_ENUM_DEPRECATED(10_3, 10_9)
(bind-val kCGLPFASingleRenderer CGLPixelFormatAttribute 71)  ;; OPENGL_ENUM_DEPRECATED(10_0, 10_9)
(bind-val kCGLPFARobust CGLPixelFormatAttribute 75)          ;; OPENGL_ENUM_DEPRECATED(10_0, 10_5)
(bind-val kCGLPFAMPSafe CGLPixelFormatAttribute 78)          ;; OPENGL_ENUM_DEPRECATED(10_0, 10_5)
(bind-val kCGLPFAMultiScreen CGLPixelFormatAttribute 81)     ;; OPENGL_ENUM_DEPRECATED(10_0, 10_5)
(bind-val kCGLPFAFullScreen CGLPixelFormatAttribute 54)      ;; OPENGL_ENUM_DEPRECATED(10_0, 10_6)

;; /*
;; ** Property names for CGLDescribeRenderer.
;; */
(bind-alias CGLRendererProperty enum)

(bind-val kCGLRPOffScreen CGLRendererProperty 53)                      
(bind-val kCGLRPRendererID CGLRendererProperty 70)                     
(bind-val kCGLRPAccelerated CGLRendererProperty 73)                    
(bind-val kCGLRPBackingStore CGLRendererProperty 76)                   
(bind-val kCGLRPWindow CGLRendererProperty 80)                         
(bind-val kCGLRPCompliant CGLRendererProperty 83)                      
(bind-val kCGLRPDisplayMask CGLRendererProperty 84)                    
(bind-val kCGLRPBufferModes CGLRendererProperty 100)            ;; /* a bitfield of supported buffer modes             */
(bind-val kCGLRPColorModes CGLRendererProperty 103)             ;; /* a bitfield of supported color buffer formats     */
(bind-val kCGLRPAccumModes CGLRendererProperty 104)             ;; /* a bitfield of supported accum buffer formats     */
(bind-val kCGLRPDepthModes CGLRendererProperty 105)             ;; /* a bitfield of supported depth buffer depths      */
(bind-val kCGLRPStencilModes CGLRendererProperty 106)           ;; /* a bitfield of supported stencil buffer depths    */
(bind-val kCGLRPMaxAuxBuffers CGLRendererProperty 107)          ;; /* maximum number of auxilliary buffers             */
(bind-val kCGLRPMaxSampleBuffers CGLRendererProperty 108)       ;; /* maximum number of sample buffers                 */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLRPMaxSamples CGLRendererProperty 109)             ;; /* maximum number of samples                        */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLRPSampleModes CGLRendererProperty 110)            ;; /* a bitfield of supported sample modes             */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLRPSampleAlpha CGLRendererProperty 111)            ;; /* support for alpha sampling                       */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLRPGPUVertProcCapable CGLRendererProperty 122)     ;; /* renderer capable of GPU vertex processing        */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLRPGPUFragProcCapable CGLRendererProperty 123)     ;; /* renderer capable of GPU fragment processing      */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLRPRendererCount CGLRendererProperty 128)          ;; /* the number of renderers in this renderer info    */
(bind-val kCGLRPOnline CGLRendererProperty 129)                 ;; /* a boolean stating if renderer is on/offline      */ OPENGL_ENUM_AVAILABLE(10_5)
(bind-val kCGLRPAcceleratedCompute CGLRendererProperty 130)     ;; /* hardware accelerated compute device              */ OPENGL_ENUM_AVAILABLE(10_6)
(bind-val kCGLRPVideoMemoryMegabytes CGLRendererProperty 131)   ;; /* total video memory (in megabytes)                */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLRPTextureMemoryMegabytes CGLRendererProperty 132) ;; /* video memory useable for textures (in megabytes) */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLRPMajorGLVersion CGLRendererProperty 133)         ;; /* maximum supported major GL revision              */ OPENGL_ENUM_AVAILABLE(10_9)
(bind-val kCGLRPRobust CGLRendererProperty 75)                  ;; OPENGL_ENUM_DEPRECATED(10_0, 10_5)
(bind-val kCGLRPMPSafe CGLRendererProperty 78)                  ;; OPENGL_ENUM_DEPRECATED(10_0, 10_5)
(bind-val kCGLRPMultiScreen CGLRendererProperty 81)             ;; OPENGL_ENUM_DEPRECATED(10_0, 10_5)
(bind-val kCGLRPFullScreen CGLRendererProperty 54)              ;; OPENGL_ENUM_DEPRECATED(10_0, 10_6)
(bind-val kCGLRPVideoMemory CGLRendererProperty 120)            ;; OPENGL_ENUM_DEPRECATED_MSG(10_0, 10_7, "Use kCGLRPVideoMemoryMegabytes")
(bind-val kCGLRPTextureMemory CGLRendererProperty 121)          ;; OPENGL_ENUM_DEPRECATED_MSG(10_0, 10_7, "Use kCGLRPTextureMemoryMegabytes")

;; /*
;; ** Enable names for CGLEnable, CGLDisable, and CGLIsEnabled.
;; */

(bind-alias CGLContextEnable enum)

(bind-val kCGLCESwapRectangle CGLContextEnable 201)           ;; /* Enable or disable the swap rectangle              */
(bind-val kCGLCESwapLimit CGLContextEnable 203)               ;; /* Enable or disable the swap async limit            */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLCERasterization CGLContextEnable 221)           ;; /* Enable or disable all rasterization               */
(bind-val kCGLCEStateValidation CGLContextEnable 301)         ;; /* Validate state for multi-screen functionality     */
(bind-val kCGLCESurfaceBackingSize CGLContextEnable 305)      ;; /* Enable or disable surface backing size override   */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLCEDisplayListOptimization CGLContextEnable 307) ;; /* Ability to turn off display list optimizer        */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLCEMPEngine CGLContextEnable 313)                ;; /* Enable or disable multi-threaded GL engine        */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLCECrashOnRemovedFunctions CGLContextEnable 316) ;; /* Die on call to function removed from Core Profile */ OPENGL_ENUM_AVAILABLE(10_7)

;; /*
;; ** Parameter names for CGLSetParameter and CGLGetParameter.
;; */
(bind-alias CGLContextParameter enum)
(bind-val kCGLCPSwapRectangle CGLContextParameter 200)          ;; /* 4 params.  Set or get the swap rectangle {x, y, w, h}        */
(bind-val kCGLCPSwapInterval CGLContextParameter 222)           ;; /* 1 param.   0 -> Don't sync, 1 -> Sync to vertical retrace    */
(bind-val kCGLCPDispatchTableSize CGLContextParameter 224)      ;; /* 1 param.   Get the dispatch table size                       */ OPENGL_ENUM_AVAILABLE(10_3)
;; /* Note: kCGLCPClientStorage is always a pointer-sized parameter, even though the API claims GLint. */
(bind-val kCGLCPClientStorage CGLContextParameter 226)          ;; /* 1 param.   Context specific generic storage                  */
(bind-val kCGLCPSurfaceTexture CGLContextParameter 228)         ;; /* 3 params.  Context, target, internal_format                  */ ;; OPENGL_ENUM_DEPRECATED(10_3, 10_9)
;; /*  - Used by AGL - */
;; /*  AGL_STATE_VALIDATION                                       230 */
;; /*  AGL_BUFFER_NAME                                            231 */
;; /*  AGL_ORDER_CONTEXT_TO_FRONT                                 232 */
;; /*  AGL_CONTEXT_SURFACE_ID                                     233 */
;; /*  AGL_CONTEXT_DISPLAY_ID                                     234 */
(bind-val kCGLCPSurfaceOrder CGLContextParameter 235)           ;; /* 1 param.   1 -> Above window, -1 -> Below Window             */ OPENGL_ENUM_AVAILABLE(10_2)
(bind-val kCGLCPSurfaceOpacity CGLContextParameter 236)         ;; /* 1 param.   1 -> Surface is opaque (default), 0 -> non-opaque */ OPENGL_ENUM_AVAILABLE(10_2)
;; /*  - Used by AGL - */
;; /*  AGL_CLIP_REGION                                            254 */
;; /*  AGL_FS_CAPTURE_SINGLE                                      255 */
(bind-val kCGLCPSurfaceBackingSize CGLContextParameter 304)     ;; /* 2 params.  Width/height of surface backing size              */ OPENGL_ENUM_AVAILABLE(10_3)
;; /*  AGL_SURFACE_VOLATILE                                       306 */
(bind-val kCGLCPSurfaceSurfaceVolatile CGLContextParameter 306) ;; /* 1 param.   Surface volatile state                            */ OPENGL_ENUM_AVAILABLE(10_3)
(bind-val kCGLCPReclaimResources CGLContextParameter 308)       ;; /* 0 params.                                                    */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLCPCurrentRendererID CGLContextParameter 309)      ;; /* 1 param.   Retrieves the current renderer ID                 */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLCPGPUVertexProcessing CGLContextParameter 310)    ;; /* 1 param.   Currently processing vertices with GPU (get)      */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLCPGPUFragmentProcessing CGLContextParameter 311)  ;; /* 1 param.   Currently processing fragments with GPU (get)     */ OPENGL_ENUM_AVAILABLE(10_4)
(bind-val kCGLCPHasDrawable CGLContextParameter 314)            ;; /* 1 param.   Boolean returned if drawable is attached*/ OPENGL_ENUM_AVAILABLE(10_5)
(bind-val kCGLCPMPSwapsInFlight CGLContextParameter 315)        ;; /* 1 param.   Max number of swaps queued by the MP GL engine*/ OPENGL_ENUM_AVAILABLE(10_5)

;; /*
;; ** Option names for CGLSetOption and CGLGetOption.
;; */
(bind-alias CGLGlobalOption enum)

(bind-val kCGLGOFormatCacheSize CGLGlobalOption 501)  ;; /* Set the size of the pixel format cache        */
(bind-val kCGLGOClearFormatCache CGLGlobalOption 502) ;; /* Reset the pixel format cache if true          */
(bind-val kCGLGORetainRenderers CGLGlobalOption 503)  ;; /* Whether to retain loaded renderers in memory  */
(bind-val kCGLGOUseBuildCache CGLGlobalOption 506)    ;; /* Enable the function compilation block cache.  */ OPENGL_ENUM_AVAILABLE(10_5)
                                                      ;; /* Off by default.  Must be enabled at startup.  */
(bind-val  kCGLGOResetLibrary CGLGlobalOption 504)    ;; OPENGL_ENUM_DEPRECATED(10_0, 10_4)
(bind-val  kCGLGOUseErrorHandler CGLGlobalOption 505) ;; OPENGL_ENUM_DEPRECATED(10_0, 10_7)

;; /*
;; ** OpenGL Implementation Profiles
;; */
(bind-alias CGLOpenGLProfile enum)

(bind-val kCGLOGLPVersion_Legacy CGLOpenGLProfile #x1000)   ;;  /* choose a renderer compatible with GL1.0       */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLOGLPVersion_3_2_Core CGLOpenGLProfile #x3200) ;;  /* choose a renderer capable of GL3.2 or later   */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLOGLPVersion_GL3_Core CGLOpenGLProfile #x3200) ;;  /* choose a renderer capable of GL3.2 or later   */ OPENGL_ENUM_AVAILABLE(10_7)
(bind-val kCGLOGLPVersion_GL4_Core CGLOpenGLProfile #x4100) ;;  /* choose a renderer capable of GL4.1 or later   */ OPENGL_ENUM_AVAILABLE(10_9)

;; /*
;; ** Error return values from CGLGetError.
;; */
(bind-alias CGLError enum)
(bind-val kCGLNoError CGLError 0)            ;; /* no error */
(bind-val kCGLBadAttribute CGLError 10000)   ;; /* invalid pixel format attribute  */
(bind-val kCGLBadProperty CGLError 10001)    ;; /* invalid renderer property       */
(bind-val kCGLBadPixelFormat CGLError 10002) ;; /* invalid pixel format            */
(bind-val kCGLBadRendererInfo CGLError 10003);; /* invalid renderer info           */
(bind-val kCGLBadContext CGLError 10004)     ;; /* invalid context                 */
(bind-val kCGLBadDrawable CGLError 10005)    ;; /* invalid drawable                */
(bind-val kCGLBadDisplay CGLError 10006)     ;; /* invalid graphics device         */
(bind-val kCGLBadState CGLError 10007)       ;; /* invalid context state           */
(bind-val kCGLBadValue CGLError 10008)       ;; /* invalid numerical value         */
(bind-val kCGLBadMatch CGLError 10009)       ;; /* invalid share context           */
(bind-val kCGLBadEnumeration CGLError 10010) ;; /* invalid enumerant               */
(bind-val kCGLBadOffScreen CGLError 10011)   ;; /* invalid offscreen drawable      */
(bind-val kCGLBadFullScreen CGLError 10012)  ;; /* invalid fullscreen drawable     */
(bind-val kCGLBadWindow CGLError 10013)      ;; /* invalid window                  */
(bind-val kCGLBadAddress CGLError 10014)     ;; /* invalid pointer                 */
(bind-val kCGLBadCodeModule CGLError 10015)  ;; /* invalid code module             */
(bind-val kCGLBadAlloc CGLError 10016)       ;; /* invalid memory allocation       */
(bind-val kCGLBadConnection CGLError 10017)  ;; /* invalid CoreGraphics connection */


;; /* 
;; ** Buffer modes
;; */
(bind-val kCGLMonoscopicBit i32 #x00000001)
(bind-val kCGLStereoscopicBit i32 #x00000002)
(bind-val kCGLSingleBufferBit i32 #x00000004)
(bind-val kCGLDoubleBufferBit i32 #x00000008)
(bind-val kCGLTripleBufferBit i32 #x00000010)

;; /*
;; ** Depth and stencil buffer depths
;; */
(bind-val kCGL0Bit i32 #x00000001)
(bind-val kCGL1Bit i32 #x00000002)
(bind-val kCGL2Bit i32 #x00000004)
(bind-val kCGL3Bit i32 #x00000008)
(bind-val kCGL4Bit i32 #x00000010)
(bind-val kCGL5Bit i32 #x00000020)
(bind-val kCGL6Bit i32 #x00000040)
(bind-val kCGL8Bit i32 #x00000080)
(bind-val kCGL10Bit i32 #x00000100)
(bind-val kCGL12Bit i32 #x00000200)
(bind-val kCGL16Bit i32 #x00000400)
(bind-val kCGL24Bit i32 #x00000800)
(bind-val kCGL32Bit i32 #x00001000)
(bind-val kCGL48Bit i32 #x00002000)
(bind-val kCGL64Bit i32 #x00004000)
(bind-val kCGL96Bit i32 #x00008000)
(bind-val kCGL128Bit i32 #x00010000)

;; /*
;; ** Color and accumulation buffer formats.
;; */
(bind-val kCGLRGB444Bit i32 #x00000040)
(bind-val kCGLARGB4444Bit i32 #x00000080)
(bind-val kCGLRGB444A8Bit i32 #x00000100)
(bind-val kCGLRGB555Bit i32 #x00000200)
(bind-val kCGLARGB1555Bit i32 #x00000400)
(bind-val kCGLRGB555A8Bit i32 #x00000800)
(bind-val kCGLRGB565Bit i32 #x00001000)
(bind-val kCGLRGB565A8Bit i32 #x00002000)
(bind-val kCGLRGB888Bit i32 #x00004000)
(bind-val kCGLARGB8888Bit i32 #x00008000)
(bind-val kCGLRGB888A8Bit i32 #x00010000)
(bind-val kCGLRGB101010Bit i32 #x00020000)
(bind-val kCGLARGB2101010Bit i32 #x00040000)
(bind-val kCGLRGB101010_A8Bit i32 #x00080000)
(bind-val kCGLRGB121212Bit i32 #x00100000)
(bind-val kCGLARGB12121212Bit i32 #x00200000)
(bind-val kCGLRGB161616Bit i32 #x00400000)
(bind-val kCGLRGBA16161616Bit i32 #x00800000)
(bind-val kCGLRGBFloat64Bit i32 #x01000000)
(bind-val kCGLRGBAFloat64Bit i32 #x02000000)
(bind-val kCGLRGBFloat128Bit i32 #x04000000)
(bind-val kCGLRGBAFloat128Bit i32 #x08000000)
(bind-val kCGLRGBFloat256Bit i32 #x10000000)
(bind-val kCGLRGBAFloat256Bit i32 #x20000000)

;; /*
;; ** Sampling modes
;; */
(bind-val kCGLSupersampleBit i32 #x00000001)
(bind-val kCGLMultisampleBit i32 #x00000002)

;; /* Obsolete */
(bind-val kCGLARGB16161616Bit i32 #x00800000) ;;kCGLRGBA16161616Bit


;; OpenGL.h

;; /*
;; ** CGL API version.
;; */
(bind-val CGL_VERSION_1_0 i32 1)
(bind-val CGL_VERSION_1_1 i32 1)
(bind-val CGL_VERSION_1_2 i32 1)
(bind-val CGL_VERSION_1_3 i32 1)

;; /*
;; ** Pixel format functions
;; */
(bind-lib libGL CGLChoosePixelFormat [CGLError,CGLPixelFormatAttribute*,CGLPixelFormatObj*,GLint*]*)
(bind-lib libGL CGLDestroyPixelFormat [CGLError,CGLPixelFormatObj]*)
(bind-lib libGL CGLDescribePixelFormat [CGLError,CGLPixelFormatObj,GLint,CGLPixelFormatAttribute,GLint*]*)
(bind-lib libGL CGLReleasePixelFormat [void,CGLPixelFormatObj]*)
(bind-lib libGL CGLRetainPixelFormat [CGLPixelFormatObj,CGLPixelFormatObj]*)
(bind-lib libGL CGLGetPixelFormatRetainCount [GLuint,CGLPixelFormatObj]*)

;; /*
;; ** Renderer information functions
;; */
(bind-lib libGL CGLQueryRendererInfo [CGLError,GLuint,CGLRendererInfoObj*,GLint*]*)
(bind-lib libGL CGLDestroyRendererInfo [CGLError,CGLRendererInfoObj]*)
(bind-lib libGL CGLDescribeRenderer [CGLError,CGLRendererInfoObj,GLint,CGLRendererProperty,GLint*]*)

;; /*
;; ** Context functions
;; */
(bind-lib libGL CGLCreateContext [CGLError,CGLPixelFormatObj,CGLContextObj,CGLContextObj*]*)
(bind-lib libGL CGLDestroyContext [CGLError,CGLContextObj]*)
(bind-lib libGL CGLCopyContext [CGLError,CGLContextObj,CGLContextObj,GLbitfield]*)
(bind-lib libGL CGLRetainContext [CGLContextObj,CGLContextObj]*)
(bind-lib libGL CGLReleaseContext [void,CGLContextObj]*)
(bind-lib libGL CGLGetContextRetainCount [GLuint,CGLContextObj]*)
(bind-lib libGL CGLGetPixelFormat [CGLPixelFormatObj,CGLContextObj]*)

;; /*
;; ** PBuffer functions
;; */
(bind-lib libGL CGLCreatePBuffer [CGLError,GLsizei,GLsizei,GLenum,GLenum,GLint,CGLPBufferObj*]*)
(bind-lib libGL CGLDestroyPBuffer [CGLError,CGLPBufferObj]*)
(bind-lib libGL CGLDescribePBuffer [CGLError,CGLPBufferObj,GLsizei*,GLsizei*,GLenum*,GLenum*,GLint*]*)
(bind-lib libGL CGLTexImagePBuffer [CGLError,CGLContextObj,CGLPBufferObj,GLenum]*)
(bind-lib libGL CGLRetainPBuffer [CGLPBufferObj,CGLPBufferObj]*)
(bind-lib libGL CGLReleasePBuffer [void,CGLPBufferObj]*)
(bind-lib libGL CGLGetPBufferRetainCount [GLuint,CGLPBufferObj]*)

;; /*
;; ** Drawable Functions
;; */
(bind-lib libGL CGLSetOffScreen [CGLError,CGLContextObj,GLsizei,GLsizei,GLint,i8*]*)
(bind-lib libGL CGLGetOffScreen [CGLError,CGLContextObj,GLsizei*,GLsizei*,GLint*,i8**]*)
(bind-lib libGL CGLSetFullScreen [CGLError,CGLContextObj]*)
(bind-lib libGL CGLSetFullScreenOnDisplay [CGLError,CGLContextObj,GLuint]*)

(bind-lib libGL CGLSetPBuffer [CGLError,CGLContextObj,CGLPBufferObj,GLenum,GLint,GLint]*)
(bind-lib libGL CGLGetPBuffer [CGLError,CGLContextObj,CGLPBufferObj*,GLenum*,GLint*,GLint*]*)

(bind-lib libGL CGLClearDrawable [CGLError,CGLContextObj]*)
(bind-lib libGL CGLFlushDrawable [CGLError,CGLContextObj]*)

;; /*
;; ** Per context enables and parameters
;; */
(bind-lib libGL CGLEnable [CGLError,CGLContextObj,CGLContextEnable]*)
(bind-lib libGL CGLDisable [CGLError,CGLContextObj,CGLContextEnable]*)
(bind-lib libGL CGLIsEnabled [CGLError,CGLContextObj,CGLContextEnable,GLint*]*)
(bind-lib libGL CGLSetParameter [CGLError,CGLContextObj,CGLContextParameter,GLint*]*)
(bind-lib libGL CGLGetParameter [CGLError,CGLContextObj,CGLContextParameter,GLint*]*)

;; /*
;; ** Virtual screen functions
;; */
(bind-lib libGL CGLSetVirtualScreen [CGLError,CGLContextObj,GLint]*)
(bind-lib libGL CGLGetVirtualScreen [CGLError,CGLContextObj,GLint*]*)

(bind-lib libGL CGLUpdateContext [CGLError,CGLContextObj]*)

;; /*
;; ** Global library options
;; */
(bind-lib libGL CGLSetGlobalOption [CGLError,CGLGlobalOption,GLint*]*)
(bind-lib libGL CGLGetGlobalOption [CGLError,CGLGlobalOption,GLint*]*)

(bind-lib libGL CGLSetOption [CGLError,CGLGlobalOption,GLint]*)
(bind-lib libGL CGLGetOption [CGLError,CGLGlobalOption,GLint*]*)

;; /*
;; ** Locking functions
;; */
(bind-lib libGL CGLLockContext [CGLError,CGLContextObj]*)

(bind-lib libGL CGLUnlockContext [CGLError,CGLContextObj]*)

;; /*
;; ** Version numbers
;; */
(bind-lib libGL CGLGetVersion [void,GLint*,GLint*]*)

;; /*
;; ** Convert an error code to a string
;; */
(bind-lib libGL CGLErrorString [i8*,CGLError]*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OpenGL context creation ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; pixel format objects

(bind-func xtgl_choose_pixel_format
  (lambda (attribs:CGLPixelFormatAttribute* pix:CGLPixelFormatObj* npix:GLint*)
    (let ((err (CGLChoosePixelFormat attribs pix npix)))
      (println "Created pixel")
      (if (<> err 0)
          (printf "Error choosing pixel format: %s\n"
                  (CGLErrorString err)))
      err)))

(bind-func xtgl_release_pixel_format
  (lambda (pix:CGLPixelFormatObj)
    (CGLReleasePixelFormat pix)))

(bind-func xtgl_describe_pixel_format
  (lambda (pix:CGLPixelFormatObj pix_num:GLint attrib:CGLPixelFormatAttribute value:GLint*)
    (let ((err (CGLDescribePixelFormat pix pix_num attrib value)))
      (if (<> err 0)
          (printf "Error describing pixel format: %s\n"
                  (CGLErrorString err)))
      err)))

(bind-func xtgl_create_compatibility_pixel_format
  (lambda (pix:CGLPixelFormatObj*)
    (let ((attribs:CGLPixelFormatAttribute* (salloc 32))
          (npix:i32* (salloc)))
      (pfill! attribs
              kCGLPFAWindow
              kCGLPFACompliant
              kCGLPFANoRecovery
              ;; ;; Add these back for multsampling	
              ;; kCGLPFAMultisample
              ;; kCGLPFASampleBuffers 1
              ;; kCGLPFASamples 4							
              kCGLPFAColorSize 24			
              kCGLPFADepthSize 24
              kCGLPFAAccumSize 24
              kCGLPFAAlphaSize 8
              kCGLPFAStencilSize 8
              kCGLPFADoubleBuffer
              kCGLPFAAccelerated
              ;; end pixel format attribs array
              0)
      (let ((err (CGLChoosePixelFormat attribs pix npix)))
        (if (<> err 0)
            (printf "Error creating compatibility pixel format: %s\n"
                    (CGLErrorString err)))
        err))))

(bind-func xtgl_create_core_pixel_format
  (lambda (pix:CGLPixelFormatObj*)
    (let ((attribs:CGLPixelFormatAttribute* (salloc 32))
          (npix:i32* (salloc)))
      (pfill! attribs
              kCGLPFAOpenGLProfile kCGLOGLPVersion_GL4_Core
              kCGLPFADoubleBuffer
              kCGLPFAAccelerated
              ;; end pixel format attribs array
              0)
      (let ((err (CGLChoosePixelFormat attribs pix npix)))
        (if (<> err 0)
            (printf "Error creating compatibility pixel format: %s\n"
                    (CGLErrorString err)))
        err))))

(bind-func xtgl_virtual_screen_count
  (lambda (pix:CGLPixelFormatObj)
    (let ((value:GLint* (salloc))
          (err (CGLDescribePixelFormat pix 0 kCGLPFAVirtualScreenCount value)))
      (if (<> err 0)
          (printf "Error in vurtual screen count: %s\n"
                  (CGLErrorString err))
          (printf "virtual screen count: %d\n" (pref value 0)))
      err)))

;; context creation

(bind-func xtgl_create_context
  (lambda (pix:CGLPixelFormatObj share:CGLContextObj ctx:CGLContextObj*)
    (let ((err (CGLCreateContext pix share ctx)))
      (if (<> err 0)
          (printf "Error creating context: %s\n"
                  (CGLErrorString err)))
      err)))

(bind-func xtgl_destroy_context
  (lambda (ctx:CGLContextObj)
    (let ((err (CGLDestroyContext ctx)))
      (if (<> err 0)
          (printf "Error destroying context: %s\n"
                  (CGLErrorString err)))
      err)))

;; global context object pointer
(bind-val XTGL_CONTEXT CGLContextObj)

;; this sets the global XTGL_CONTEXT
(bind-func xtgl_create_context_core_profile
  (lambda ()
    (let ((ctx:CGLContextObj* (alloc))
          (pix:CGLPixelFormatObj* (salloc))
          (err:CGLError 0))
      (set! err (xtgl_create_core_pixel_format pix))
      (if (and (= err 0) (not (null? pix)))
          (begin (set! err (xtgl_create_context (pref pix 0) null ctx))
                 (if (= err 0)
                     (set! XTGL_CONTEXT (pref ctx 0)))))
      err)))

;; this sets the global XTGL_CONTEXT
(bind-func xtgl_create_context_core_profile
  (lambda ()
    (let ((ctx:CGLContextObj* (alloc))
          (pix:CGLPixelFormatObj* (salloc))
          (err:CGLError 0))
      (set! err (xtgl_create_compatibility_pixel_format pix))
      (if (and (= err 0) (not (null? pix)))
          (begin (set! err (xtgl_create_context (pref pix 0) null ctx))
                 (if (= err 0)
                     (set! XTGL_CONTEXT (pref ctx 0)))))
      err)))

;;;;;;;;;;;;;
;; testing ;;
;;;;;;;;;;;;;

;; (xtgl_create_context_core_profile)

(bind-func xtgl_print_context_pointer
  (lambda ()
    (printf "XTGL_CONTEXT: %p\n" XTGL_CONTEXT)))

;; (xtgl_print_driver_info)

;; hacky OSX stuff

;; load the dylib               
(define Cocoa (sys:load-dylib "/System/Library/Frameworks/Cocoa.framework/Cocoa"))

(bind-alias id i8*)
(bind-alias BOOL i8)

(bind-lib Cocoa objc_msgSend [id,i8*,i8*])
(bind-lib Cocoa objc_getClass [id,i8*])
(bind-lib Cocoa sel_getUid [id,i8*])

(bind-alias CGFloat double) ;; on 64-bit
(bind-alias NSUInteger i64) ;; on 64-bit

(bind-type CGPoint <CGFloat,CGFloat>) ;; <x,y>
(bind-type CGSize <CGFloat,CGFloat>) ;; <width,height>
(bind-type CGRect <CGPoint,CGSize>) ;; <origin,size>

(bind-val NSBorderlessWindowMask enum 0)
(bind-val NSTitledWindowMask enum 1) ;; 1 << 0
(bind-val NSClosableWindowMask enum 2) ;; 1 << 1
(bind-val NSMiniaturizableWindowMask enum 4) ;; 1 << 2
(bind-val NSResizableWindowMask enum 1 << 8) ;; 1 << 3
(bind-val NSTexturedBackgroundWindowMask enum 128)

(bind-val NSBackingStoreBuffered enum 2)

(bind-func xtgl_create_window
  (lambda ()
    (let ((window (objc_msgSend (objc_getClass "NSWindow")
                                (sel_getUid "alloc")))
          (style_mask (+ NSTitledWindowMask
                         NSClosableWindowMask
                         NSMiniaturizableWindowMask)))
      (printf "window: %p\n" window)
      void)))

;; (xtgl_create_window) ;; this works!

 ;; self->window = objc_msgSend(objc_getClass("NSWindow"), sel_getUid("alloc"));
 ;; self->window = objc_msgSend(self->window, sel_getUid("initWithContentRect:styleMask:backing:defer:"), (struct CGRect) { 0, 0, 320, 480 }, blah...);

;; ;; guff starts here
;; (bind-func xtm_dlsym
;;   (lambda (lib:i8* symname:i8*)
;;     (dlsym lib symname)))

;; (bind-val GL_DEPTH_ATTACHMENT i32 #x8D00)
;; (bind-lib libGL glBindFramebuffer [void,GLenum,GLuint]*)

;; (xtm_dlsym libGL "glBindFramebuffer")

(define *xtmlib-gl-osx-loaded* #t)
