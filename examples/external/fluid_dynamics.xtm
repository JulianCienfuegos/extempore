;;; fluid_dynamics.xtm -- a simple fluid dynamics example

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; A nice and simple 3d fluid simulation
;; based on code from Jos Stam and Mike Ash.

;; This little example is nice and simple
;; The computation is all on the CPU and
;; the density of each cell is drawn using
;; very simple immediate OpenGL calls.
;; The importance of this example is to demonstrate
;; Extempore's ability to bind to arbitrary dynamic
;; libraries at runtime.  In this case OpenCV.
;;
;; The simulation is a little smoke sim
;; with constant air streams from bottom->top
;; and from left->right.  Smoke is injected
;; into the system semi-regularly.

;;; Code:

;; First the fluid dynamics code

;; code here largely pilfered from from
;; Jos Stam and Mike Ash

(define width 1920.0)
(define height 1080.0)
(bind-val width float 1920.0)
(bind-val height float 1080.0)
(define fullscreen #t)

(define *gl-ctx* (gl:make-ctx ":0.0" #f 0.0 0.0 width height))

;; try xtm.xtm first
(sys:load "libs/xtm.xtm")
;; else fallback
(sys:load "libs/external/opengl.xtm")

(bind-type fluidcube <i64,float,float,float,float*,float*,float*,float*,float*,float*,float*,float*>)

(bind-func index_xyz
  (lambda (x:i64 y:i64 z:i64 side_length:i64)
    (+ x (* y side_length) (* z side_length side_length))))

(bind-func fc_create
  (lambda (side_length diffusion viscosity dt:float)
    (let ((cube:fluidcube* (heap-alloc))
          (buffer_size:i64 (* side_length side_length side_length))
          (s:float* (heap-alloc buffer_size))
          (density:float* (heap-alloc buffer_size))
          (Vx:float* (heap-alloc buffer_size))
          (Vy:float* (heap-alloc buffer_size))
          (Vz:float* (heap-alloc buffer_size))
          (Vx0:float* (heap-alloc buffer_size))
          (Vy0:float* (heap-alloc buffer_size))
          (Vz0:float* (heap-alloc buffer_size)))
      (tfill! cube side_length dt diffusion viscosity s density Vx Vy Vz Vx0 Vy0 Vz0)
      cube)))

(bind-func fc_add_density
  (lambda (cube:fluidcube* x y z dD:float)
    (let ((side_length (tref cube 0))
          (idx (index_xyz x y z side_length))
          (density_ptr:float* (tref cube 5))
          (new_density (+ (pref density_ptr idx) dD)))
      (pset! density_ptr idx new_density)
      void)))

(bind-func fc_add_velocity
  (lambda (cube:fluidcube* x y z dVx:double dVy:double dVz:double)
    (let ((side_length (tref cube 0))
          (idx (index_xyz x y z side_length))
          (Vx (tref cube 6))
          (Vy (tref cube 7))
          (Vz (tref cube 8)))
      (pset! Vx idx (+ dVx (pref Vx idx)))
      (pset! Vy idx (+ dVy (pref Vy idx)))
      (pset! Vz idx (+ dVz (pref Vz idx)))
      void)))

(bind-func fc_set_boundary
  (lambda (b:i64 x:float* side_length:i64)
    (let ((sl-1 (- side_length 1))
          (sl-2 (- side_length 2))
          (i 0) (i-1 (- i 1))
          (j 0) (j-1 (- j 1)))	      
      (dotimes (j sl-2)
        (dotimes (i sl-2)
          (pset! x (index_xyz i-1 j-1 0 side_length)
                 (if (= b 3)
                     (- 0.0 (pref x (index_xyz i-1 j-1 1 side_length)))
                     (pref x (index_xyz i-1 j-1 1 side_length))))
          (pset! x (index_xyz i-1 j-1 sl-1 side_length)
                 (if (= b 3)		   
                     (- 0.0 (pref x (index_xyz i-1 j-1 sl-2 side_length)))
                     (pref x (index_xyz i-1 j-1 sl-2 side_length))))))
      (dotimes (j sl-2)
        (dotimes (i sl-2)
          (pset! x (index_xyz i-1 0 j-1 side_length)
                 (if (= b 2)		   
                     (- 0.0 (pref x (index_xyz i-1 1 j-1 side_length)))
                     (pref x (index_xyz i-1 1 j-1 side_length))))
          (pset! x (index_xyz i-1 sl-1 j-1 side_length)
                 (if (= b 2)		   
                     (- 0.0 (pref x (index_xyz i-1 sl-2 j-1 side_length)))
                     (pref x (index_xyz i-1 sl-2 j-1 side_length))))))
      (dotimes (j sl-2)
        (dotimes (i sl-2)
          (pset! x (index_xyz 0 i-1 j-1 side_length)
                 (if (= b 1)	       
                     (- 0.0 (pref x (index_xyz 1 i-1 j-1 side_length)))
                     (pref x (index_xyz 1 i-1 j-1 side_length))))
          (pset! x (index_xyz sl-1 i-1 j-1 side_length)
                 (if (= b 1)	       
                     (- 0.0 (pref x (index_xyz sl-2 i-1 j-1 side_length)))
                     (pref x (index_xyz sl-2 i-1 j-1 side_length))))))

      (pset! x (index_xyz 0 0 0 side_length)
             (* 0.33333 (+ (pref x (index_xyz 1 0 0 side_length))
                           (pref x (index_xyz 0 1 0 side_length))
                           (pref x (index_xyz 0 0 1 side_length)))))
      (pset! x (index_xyz 0 sl-1 0 side_length)
             (* 0.33333 (+ (pref x (index_xyz 1 sl-1 0 side_length))
                           (pref x (index_xyz 0 sl-2 0 side_length))
                           (pref x (index_xyz 0 sl-1 1 side_length)))))
      (pset! x (index_xyz 0 0 sl-1 side_length)
             (* 0.33333 (+ (pref x (index_xyz 1 0 sl-1 side_length))
                           (pref x (index_xyz 0 1 sl-1 side_length))
                           (pref x (index_xyz 0 0 side_length side_length)))))
      (pset! x (index_xyz 0 sl-1 sl-1 side_length)
             (* 0.33333 (+ (pref x (index_xyz 1 sl-1 sl-1 side_length))
                           (pref x (index_xyz 0 sl-2 sl-1 side_length))
                           (pref x (index_xyz 0 sl-1 sl-2 side_length)))))
      (pset! x (index_xyz sl-1 0 0 side_length)
             (* 0.33333 (+ (pref x (index_xyz sl-2 0 0 side_length))
                           (pref x (index_xyz sl-1 1 0 side_length))
                           (pref x (index_xyz sl-1 0 1 side_length)))))
      (pset! x (index_xyz sl-1 sl-1 0 side_length)
             (* 0.33333 (+ (pref x (index_xyz sl-2 sl-1 0 side_length))
                           (pref x (index_xyz sl-1 sl-2 0 side_length))
                           (pref x (index_xyz sl-1 sl-1 1 side_length)))))
      (pset! x (index_xyz sl-1 0 sl-1 side_length)
             (* 0.33333 (+ (pref x (index_xyz sl-2 0 sl-1 side_length))
                           (pref x (index_xyz sl-1 1 sl-1 side_length))
                           (pref x (index_xyz sl-1 0 sl-2 side_length)))))
      (pset! x (index_xyz sl-1 sl-1 sl-1 side_length)
             (* 0.33333 (+ (pref x (index_xyz sl-2 sl-1 sl-1 side_length))
                           (pref x (index_xyz sl-1 sl-2 sl-1 side_length))
                           (pref x (index_xyz sl-1 sl-1 sl-2 side_length)))))
      void)))

(bind-func fc_lin_solve
  (lambda (b:i64 x:float* x0:float* a c iter:i64 side_length:i64)
    (let ((c_reciprocal (/ 1.0 c))
          (m 0)
          (i 0) (j 0) (k 0))
      (dotimes (k iter)
        (dotimes (m (- side_length 2))
          (dotimes (j (- side_length 2))
            (dotimes (i (- side_length 2))
              (pset! x (index_xyz (+ i 1) (+ j 1) (+ m 1) side_length)
                     (* c_reciprocal
                        (+ (pref x0 (index_xyz (+ i 1) (+ j 1) (+ m 1) side_length))
                           (* a (+ (pref x (index_xyz (+ i 2) (+ j 1) (+ m 1) side_length))
                                   (pref x (index_xyz i (+ j 1) (+ m 1) side_length))
                                   (pref x (index_xyz (+ i 1) (+ j 2) (+ m 1) side_length))
                                   (pref x (index_xyz (+ i 1) j (+ m 1) side_length))
                                   (pref x (index_xyz (+ i 1) (+ j 1) (+ m 2) side_length))
                                   (pref x (index_xyz (+ i 1) (+ j 1) m side_length))))))))))
        (fc_set_boundary b x side_length)))
    void))

(bind-func fc_diffuse
  (lambda (b:i64 x:float* x0:float* diff:float dt:float iter N)
    (let ((a:float (* dt diff (convert (* (- N 2) (- N 2))))))
      (fc_lin_solve b x x0 a (+ 1.0 (* 6.0 a)) iter N))))


(bind-func fc_project
  (lambda (velocx:float* velocy:float* velocz:float* p:float* div:float* iter side_length)
    (let ((i 0) (j 0) (k 0))
      (dotimes (k (- side_length 2))
        (dotimes (j (- side_length 2))
          (dotimes (i (- side_length 2))
            (pset! div (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length)
                   (* -0.5 (/ (+ (- (pref velocx (index_xyz (+ i 2) (+ j 1) (+ k 1) side_length))
                                    (pref velocx (index_xyz i (+ j 1) (+ k 1) side_length)))
                                 (- (pref velocy (index_xyz (+ i 1) (+ j 2) (+ k 1) side_length))
                                    (pref velocy (index_xyz (+ i 1) j (+ k 1) side_length)))
                                 (- (pref velocz (index_xyz (+ i 1) (+ j 1) (+ k 2) side_length))
                                    (pref velocz (index_xyz (+ i 1) (+ j 1) k side_length))))
                              (convert side_length))))
            (pset! p (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length) 0.0))))
      (fc_set_boundary 0 div side_length)
      (fc_set_boundary 0 p side_length)
      (fc_lin_solve 0 p div 1.0 6.0 iter side_length)
      
      (dotimes (k (- side_length 2))
        (dotimes (j (- side_length 2))
          (dotimes (i (- side_length 2))
            (pset! velocx (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length)
                   (- (pref velocx (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length))
                      (* 0.5
                         (- (pref p (index_xyz (+ i 2) (+ j 1) (+ k 1) side_length))
                            (pref p (index_xyz (+ i 0) (+ j 1) (+ k 1) side_length)))
                         (convert side_length))))
            (pset! velocy (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length)
                   (- (pref velocy (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length))
                      (* 0.5
                         (- (pref p (index_xyz (+ i 1) (+ j 2) (+ k 1) side_length))
                            (pref p (index_xyz (+ i 1) (+ j 0) (+ k 1) side_length)))
                         (convert side_length))))
            (pset! velocz (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length)
                   (- (pref velocz (index_xyz (+ i 1) (+ j 1) (+ k 1) side_length))
                      (* 0.5
                         (- (pref p (index_xyz (+ i 1) (+ j 1) (+ k 2) side_length))
                            (pref p (index_xyz (+ i 1) (+ j 1) (+ k 0) side_length)))
                         (convert side_length)))))))
      (fc_set_boundary 1 velocx side_length)
      (fc_set_boundary 2 velocy side_length)
      (fc_set_boundary 3 velocz side_length)
      void)))


(bind-func fc_advect
  (lambda (b:i64 d:float* d0:float* velocx:float* velocy:float* velocz:float* dt:float N:i64)
    (let ((dtx (* dt (convert (- N 2)))) (dty dtx) (dtz dty)
          (kfloat:float 0.0) (jfloat:float 0.0) (ifloat:float 0.0)
          (s0:float 0.0) (s1:float 0.0) (t0:float 0.0) (t1:float 0.0) (u0:float 0.0) (u1:float 0.0)
          (i0:float 0.0) (i0i:i64 0) (i1:float 0.0) (i1i:i64 0)
          (j0:float 0.0) (j0i:i64 0) (j1:float 0.0) (j1i:i64 0)
          (k 0) (j 0) (i 0)
          (tmp1:float 0.0) (tmp2:float 0.0) (tmp3:float 0.0)
          (x:float 0.0) (y:float 0.0) (z:float 0.0)
          (k0:float 0.0) (k0i:i64 0) (k1:float 0.0) (k1i:i64 0)
          (Nfloat (convert N)))
      (dotimes (k (- N 2))
        (set! kfloat (+ kfloat 1.0))
        (set! jfloat 0.0)
        (dotimes (j (- N 2))
          (set! jfloat (+ jfloat 1.0))
          (set! ifloat 0.0)
          (dotimes (i (- N 2))
            (set! ifloat (+ ifloat 1.0))
            (set! tmp1 (* dtx (pref velocx (index_xyz (+ i 1) (+ j 1) (+ k 1) N))))
            (set! tmp2 (* dty (pref velocy (index_xyz (+ i 1) (+ j 1) (+ k 1) N))))
            (set! tmp3 (* dtz (pref velocz (index_xyz (+ i 1) (+ j 1) (+ k 1) N))))
            (set! x (- ifloat tmp1))
            (set! y (- jfloat tmp2))
            (set! z (- kfloat tmp3))
            
            (if (< x 0.5) (set! x 0.5))
            (if (> x (+ Nfloat 0.5)) (set! x (+ Nfloat 0.5)))
            (set! i0 (floor x))
            (set! i1 (+ i0 1.0))
            (if (< y 0.5) (set! y 0.5))
            (if (> y (+ Nfloat 0.5)) (set! y (+ Nfloat 0.5)))
            (set! j0 (floor y))
            (set! j1 (+ j0 1.0))
            (if (< z 0.5) (set! z 0.5))
            (if (> z (+ Nfloat 0.5)) (set! z (+ Nfloat 0.5)))
            (set! k0 (floor z))
            (set! k1 (+ k0 1.0))

            (set! s1 (- x i0))
            (set! s0 (- 1.0 s1))
            (set! t1 (- y j0))
            (set! t0 (- 1.0 t1))
            (set! u1 (- z k0))
            (set! u0 (- 1.0 u1))

            (set! i0i (convert i0))
            (set! i1i (convert i1))	      
            (set! j0i (convert j0))
            (set! j1i (convert j1))	      
            (set! k0i (convert k0))
            (set! k1i (convert k1))

            (pset! d (index_xyz (+ i 1) (+ j 1) (+ k 1) N)
                   (+ (* s0 (+ (* t0 (+ (* u0 (pref d0 (index_xyz i0i j0i k0i N)))
                                        (* u1 (pref d0 (index_xyz i0i j0i k1i N)))))
                               (* t1 (+ (* u0 (pref d0 (index_xyz i0i j1i k0i N)))
                                        (* u1 (pref d0 (index_xyz i0i j1i k1i N)))))))
                      (* s1 (+ (* t0 (+ (* u0 (pref d0 (index_xyz i1i j0i k0i N)))
                                        (* u1 (pref d0 (index_xyz i1i j0i k1i N)))))
                               (* t1 (+ (* u0 (pref d0 (index_xyz i1i j1i k0i N)))
                                        (* u1 (pref d0 (index_xyz i1i j1i k1i N))))))))))))
      
      (fc_set_boundary b d N))))

(bind-func fc_step_cube
  (lambda (cube:fluidcube*)
    (let ((N (tref cube 0))
          (dt (tref cube 1))	  
          (diff (tref cube 2))
          (visc (tref cube 3))	  
          (s (tref cube 4))
          (i 0)
          (density (tref cube 5))
          (Vx (tref cube 6))
          (Vy (tref cube 7))
          (Vz (tref cube 8))
          (Vx0 (tref cube 9))
          (Vy0 (tref cube 10))
          (Vz0 (tref cube 11)))
      
      (fc_diffuse 1 Vx0 Vx visc dt 4 N)
      (fc_diffuse 2 Vy0 Vy visc dt 4 N)
      (fc_diffuse 3 Vz0 Vz visc dt 4 N)

      (dotimes (i (* N N N))
      	(pset! Vx i 0.0)
      	(pset! Vy i 0.0)
      	(pset! Vz i 0.0))
      
      (fc_project Vx0 Vy0 Vz0 Vx Vy 4 N)

      (fc_advect 1 Vx Vx0 Vx0 Vy0 Vz0 dt N)
      (fc_advect 2 Vy Vy0 Vx0 Vy0 Vz0 dt N)
      (fc_advect 3 Vz Vz0 Vx0 Vy0 Vz0 dt N)

      (dotimes (i (* N N N))
      	(pset! Vx0 i 0.0)
      	(pset! Vy0 i 0.0)
      	(pset! Vz0 i 0.0))
      
      (fc_project Vx Vy Vz Vx0 Vy0 4 N)
      (fc_diffuse 0 s density diff dt 4 N)
      (fc_advect 0 density s Vx Vy Vz dt N))
    void))

(bind-func fc_get
  (let ((cube (fc_create 22 0.001 0.001 0.002)))
    (lambda ()
      cube)))

(bind-func fc_clean
  (lambda ()    
    (let ((densities (tref (fc_get) 5))
          (Vx (tref (fc_get) 6)) (Vy (tref (fc_get) 7)) (Vz (tref (fc_get) 8))
          (x 0) (y 0) (z 0)	  
          (size (tref (fc_get) 0)))
      (dotimes (x size)
        (dotimes (y size)
          (dotimes (z size)
            (let ((idx (index_xyz x y z size)))
              (pset! Vx idx 0.0)
              (pset! Vy idx 0.0)
              (pset! Vz idx 0.0)
              (pset! densities idx 0.0))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Next Some OpenGL Stuff

(gl_set_view width height 200.0)

(bind-func some_gl_init
  (lambda ()
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA (+ GL_SRC_ALPHA 1))            
    (glDisable GL_DEPTH_TEST)))

(bind-func add_density
  (lambda (x y z dD)
    (let ((cube (fc_get)))
      (fc_add_density cube x y z dD))))

(bind-func add_velocity
  (lambda (x y z dVx dVy dVz)
    (fc_add_velocity (fc_get) x y z dVx dVy dVz)))

(bind-func get_velocity
  (lambda (x y z)
    (let ((xs (tref (fc_get) 6))
          (side_length (tref (fc_get) 0)))
      (pref xs (index_xyz x y z side_length)))))


(bind-func look-at
  (lambda (eyex eyey eyez centre_x centre_y centre_z up_x up_y up_z)
    (glLoadIdentity)
    (gluLookAt eyex eyey eyez centre_x centre_y centre_z up_x up_y up_z)))


(bind-func glCube
  (let ((dlist -1))
    (lambda ()
      (if (> dlist -1)
          (begin
            (glCallList dlist)
            (set! dlist (glGenLists 1))
            (glNewList dlist (+ GL_COMPILE 1))
            (glBegin GL_QUADS)
            ;; Front face
            (glNormal3d 0.0 0.0 1.0)
            (glVertex3d 0.0 0.0  1.0)
            (glVertex3d 1.0 0.0  1.0)
            (glVertex3d 1.0  1.0  1.0)
            (glVertex3d 0.0  1.0  1.0)
            ;; Back face
            (glNormal3d 0.0 0.0 -1.0)
            (glVertex3d 0.0 0.0 0.0)
            (glVertex3d 0.0  1.0 0.0)
            (glVertex3d 1.0  1.0 0.0)
            (glVertex3d 1.0 0.0 0.0)
            ;; Top face
            (glNormal3d 0.0 1.0 0.0)
            (glVertex3d 0.0  1.0 0.0)
            (glVertex3d 0.0  1.0  1.0)
            (glVertex3d 1.0  1.0  1.0)
            (glVertex3d 1.0  1.0 0.0)
            ;; Bottom face
            (glNormal3d 0.0 -1.0 0.0)
            (glVertex3d 0.0 0.0 0.0)
            (glVertex3d 1.0 0.0 0.0)
            (glVertex3d 1.0 0.0  1.0)
            (glVertex3d 0.0 0.0  1.0)
            ;; Right face
            (glNormal3d 1.0 0.0 0.0)
            (glVertex3d 1.0 0.0 0.0)
            (glVertex3d 1.0  1.0 0.0)
            (glVertex3d 1.0  1.0  1.0)
            (glVertex3d 1.0 0.0  1.0)
            ;; Left face
            (glNormal3d -1.0 0.0 0.0)
            (glVertex3d 0.0 0.0 0.0)
            (glVertex3d 0.0 0.0  1.0)
            (glVertex3d 0.0  1.0  1.0)
            (glVertex3d 0.0  1.0 0.0)
            (glEnd)
            (glEndList)
            void)))))


;; a trivial opengl draw loop
(bind-func gl_loop
  (let ((degree 0.0))
    (lambda ()
      ;; (glClearColor 1.0 0.5 0.0 1.0)
      (glClearColor 0.0 0.0 0.0 1.0)      
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (glColor4d 0.0 0.0 0.0 1.0)
      (glLineWidth 1.0)
      (glLoadIdentity)
      (glTranslated -10.0 -10.0 -50.0)

      (fc_step_cube (fc_get))
      (let ((densities (tref (fc_get) 5))
            (i 0) (j 0) (k 0)	    
      	    (Vx (tref (fc_get) 6))
      	    (Vy (tref (fc_get) 7))
      	    (Vz (tref (fc_get) 8))	    
      	    (side_length (tref (fc_get) 0)))
        
        (glTranslated 10.0 11.0 11.0)
        (glRotated (* 300.0 degree) 0.0 1.0 0.0)
        (glTranslated -10.0 -11.0 -11.0)
        
      	(dotimes (i 0 side_length)
      	  (dotimes (j 0 side_length)
      	    (dotimes (k 0 side_length)
              (let ((idx (index_xyz i j k side_length))
                    (norm (convert
                           (sqrt (+ (* (pref Vx idx) (pref Vx idx))
                                    (* (pref Vy idx) (pref Vy idx))
                                    (* (pref Vz idx) (pref Vz idx)))))))
                (glPushMatrix)
                (glTranslated (convert i) (convert j) (convert k))
                (glColor4d 0.8 1.0 0.4 (convert (pref densities idx)))
                (glCube)
                ;; turn 0.2 to 0.0 to stop drawing vertex arrows
                (glColor4d 1.0 1.0 1.0 1.0)
                ;; if you're having performance problems you
                ;; could start by commenting out the next 4 lines
                ;; i.e. stop drawing the red velocity arrows
                (glBegin GL_LINES)
                (glVertex3d 0.5 0.5 0.5)
                (glVertex3d (+ 0.5 (* 0.5 (/ (convert (pref Vx idx)) norm)))
                            (+ 0.5 (* 0.5 (/ (convert (pref Vy idx)) norm)))
                            (+ 0.5 (* 0.5 (/ (convert (pref Vz idx)) norm))))
                (glEnd)
                (glPopMatrix))))))
      
      (set! degree (+ degree .001))
      void)))

;; gl-loop includes two sources
;; of constant wind speed
;;
;; bottom->top: straight up the middle
;; left->right: oscillates from back to front
;;
;; You might need to slow the rate of this
;; temporal recursion down if your machine
;; doesn't cope.  (i.e. 3000 to 5000 or more
;;
;; standard impromptu callback
(define gl-loop
  (lambda (time degree)
    (gl_loop)
    ;; 1000.0 is wind speed from bottom to top
    (add_velocity 11 1 11 0.0 1000.0 0.0)
    ;; 600.0 is wind speed from left to right
    (add_velocity 2 5 11 300.0 0.0 (+ 200.0 (* 200.0 (cos (* 100.0 degree)))))
    ;; everynow and then remove smoke from cube
    (if (< (modulo degree 1.0) 0.005) (fc_clean))
    (gl:swap-buffers *gl-ctx*)
    (callback time 'gl-loop (+ time 3000) (+ degree 0.001))))

;;
;; Smoke signal injects smoke into the system
;; at semi-regular intervals (* 40000 (random 4 9))
;;
(define smoke-signal
  (lambda (time)
    ;; increase 300.0 to kick more smoke into the system 
    (add_density 2 5 11 (+ 1.0 (* (random) 50.0)))    
    ;; decrease (random 4 9) to inject smoke more often
    (callback (+ time 4410) 'smoke-signal (+ time (* 40000 (random 4 9))))))


(gl-loop (now) 0.0)
(some_gl_init)
(smoke-signal (now))

;; eval this again if you want to clean the cube at some point!
; (fc_clean)
