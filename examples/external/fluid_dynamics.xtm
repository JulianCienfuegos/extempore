;;; fluid_dynamics.xtm -- a simple fluid dynamics example

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; A nice and simple 3d fluid simulation
;; based on code from Jos Stam and Mike Ash.

;; This little example is nice and simple
;; The computation is all on the CPU and
;; the density of each cell is drawn using
;; very simple immediate OpenGL calls.
;; The importance of this example is to demonstrate
;; Extempore's ability to bind to arbitrary dynamic
;; libraries at runtime.  In this case OpenCV.
;;
;; The simulation is a little smoke sim
;; with constant air streams from bottom->top
;; and from left->right.  Smoke is injected
;; into the system semi-regularly.

;;; Code:

;; First the fluid dynamics code

;; code here largely pilfered from from
;; Jos Stam and Mike Ash

(define width 1920.0)
(define height 1080.0)
(bind-val width float 1920.0)
(bind-val height float 1080.0)
(define fullscreen #t)

(define *gl-ctx* (gl:make-ctx ":0.0" fullscreen 0.0 0.0 width height))

;; try xtm.xtm first
(sys:load "libs/xtm.xtm")
;; else fallback
(sys:load "libs/external/opengl.xtm")

(bind-type fluidcube <i64,float,float,float,float*,float*,float*,float*,float*,float*,float*,float*>)

(bind-val FLUIDCUBE fluidcube* 0)

(bind-func fc_null
  (lambda ()
    (set! FLUIDCUBE (cast null fluidcube*))))
(fc_null)

(bind-func index_xyz
  (lambda (x:i64 y:i64 z:i64 dim:i64)
    (+ x (* y dim) (* z dim dim))))

(bind-func fc_destroy
  (lambda ()
    (if (not (null? FLUIDCUBE))
        (begin
          (if (not (null? (tref FLUIDCUBE 4))) (free (tref FLUIDCUBE 4)))
          (if (not (null? (tref FLUIDCUBE 5))) (free (tref FLUIDCUBE 5)))
          (if (not (null? (tref FLUIDCUBE 6))) (free (tref FLUIDCUBE 6)))
          (if (not (null? (tref FLUIDCUBE 7))) (free (tref FLUIDCUBE 7)))
          (if (not (null? (tref FLUIDCUBE 8))) (free (tref FLUIDCUBE 8)))
          (if (not (null? (tref FLUIDCUBE 9))) (free (tref FLUIDCUBE 9)))
          (if (not (null? (tref FLUIDCUBE 10))) (free (tref FLUIDCUBE 10)))
          (if (not (null? (tref FLUIDCUBE 11))) (free (tref FLUIDCUBE 11)))
          (free FLUIDCUBE))
        (begin (printf "FLUIDCUBE is null.\n")
               void))))

;; dim = side length. full cube is (* dim dim dim) cells
(bind-func fc_create
  (lambda (dim diffusion viscosity dt:float)
    (if (not (null? FLUIDCUBE))
        (fc_destroy))
    (let ((cube:fluidcube* (heap-alloc))
          (buffer_size:i64 (* dim dim dim))
          (s:float* (heap-alloc buffer_size))
          (density:float* (heap-alloc buffer_size))
          (Vx:float* (heap-alloc buffer_size))
          (Vy:float* (heap-alloc buffer_size))
          (Vz:float* (heap-alloc buffer_size))
          (Vx0:float* (heap-alloc buffer_size))
          (Vy0:float* (heap-alloc buffer_size))
          (Vz0:float* (heap-alloc buffer_size)))
      (set! FLUIDCUBE cube)
      (printf "created new FLUIDCUBE at %p\n" FLUIDCUBE)
      (tfill! FLUIDCUBE dim dt diffusion viscosity s density Vx Vy Vz Vx0 Vy0 Vz0))))

(bind-func fc_clean
  (lambda ()    
    (let ((densities (tref FLUIDCUBE 5))
          (Vx (tref FLUIDCUBE 6)) (Vy (tref FLUIDCUBE 7)) (Vz (tref FLUIDCUBE 8))
          (x 0) (y 0) (z 0)	  
          (size (tref FLUIDCUBE 0)))
      (dotimes (x size)
        (dotimes (y size)
          (dotimes (z size)
            (let ((idx (index_xyz x y z size)))
              (pset! Vx idx 0.0)
              (pset! Vy idx 0.0)
              (pset! Vz idx 0.0)
              (pset! densities idx 0.0))))))))

;; the fluid dynamics stuff

(bind-func fc_add_density
  (lambda (x y z dD:float)
    (let ((dim (tref FLUIDCUBE 0))
          (idx (index_xyz x y z dim))
          (density_ptr:float* (tref FLUIDCUBE 5))
          (new_density (+ (pref density_ptr idx) dD)))
      (pset! density_ptr idx new_density)
      void)))

(bind-func fc_add_velocity
  (lambda (x y z dVx:double dVy:double dVz:double)
    (let ((dim (tref FLUIDCUBE 0))
          (idx (index_xyz x y z dim))
          (Vx (tref FLUIDCUBE 6))
          (Vy (tref FLUIDCUBE 7))
          (Vz (tref FLUIDCUBE 8)))
      (pset! Vx idx (+ dVx (pref Vx idx)))
      (pset! Vy idx (+ dVy (pref Vy idx)))
      (pset! Vz idx (+ dVz (pref Vz idx)))
      void)))

(bind-func fc_set_boundary
  (lambda (b:i64 x:float* dim:i64)
    (let ((dim-1 (- dim 1))
          (dim-2 (- dim 2))
          (i 0) (i-1 (- i 1))
          (j 0) (j-1 (- j 1)))	      
      (dotimes (j dim-2)
        (dotimes (i dim-2)
          (pset! x (index_xyz i-1 j-1 0 dim)
                 (if (= b 3)
                     (- 0.0 (pref x (index_xyz i-1 j-1 1 dim)))
                     (pref x (index_xyz i-1 j-1 1 dim))))
          (pset! x (index_xyz i-1 j-1 dim-1 dim)
                 (if (= b 3)		   
                     (- 0.0 (pref x (index_xyz i-1 j-1 dim-2 dim)))
                     (pref x (index_xyz i-1 j-1 dim-2 dim))))))
      (dotimes (j dim-2)
        (dotimes (i dim-2)
          (pset! x (index_xyz i-1 0 j-1 dim)
                 (if (= b 2)		   
                     (- 0.0 (pref x (index_xyz i-1 1 j-1 dim)))
                     (pref x (index_xyz i-1 1 j-1 dim))))
          (pset! x (index_xyz i-1 dim-1 j-1 dim)
                 (if (= b 2)		   
                     (- 0.0 (pref x (index_xyz i-1 dim-2 j-1 dim)))
                     (pref x (index_xyz i-1 dim-2 j-1 dim))))))
      (dotimes (j dim-2)
        (dotimes (i dim-2)
          (pset! x (index_xyz 0 i-1 j-1 dim)
                 (if (= b 1)	       
                     (- 0.0 (pref x (index_xyz 1 i-1 j-1 dim)))
                     (pref x (index_xyz 1 i-1 j-1 dim))))
          (pset! x (index_xyz dim-1 i-1 j-1 dim)
                 (if (= b 1)	       
                     (- 0.0 (pref x (index_xyz dim-2 i-1 j-1 dim)))
                     (pref x (index_xyz dim-2 i-1 j-1 dim))))))

      (pset! x (index_xyz 0 0 0 dim)
             (* 0.33333 (+ (pref x (index_xyz 1 0 0 dim))
                           (pref x (index_xyz 0 1 0 dim))
                           (pref x (index_xyz 0 0 1 dim)))))
      (pset! x (index_xyz 0 dim-1 0 dim)
             (* 0.33333 (+ (pref x (index_xyz 1 dim-1 0 dim))
                           (pref x (index_xyz 0 dim-2 0 dim))
                           (pref x (index_xyz 0 dim-1 1 dim)))))
      (pset! x (index_xyz 0 0 dim-1 dim)
             (* 0.33333 (+ (pref x (index_xyz 1 0 dim-1 dim))
                           (pref x (index_xyz 0 1 dim-1 dim))
                           (pref x (index_xyz 0 0 dim dim)))))
      (pset! x (index_xyz 0 dim-1 dim-1 dim)
             (* 0.33333 (+ (pref x (index_xyz 1 dim-1 dim-1 dim))
                           (pref x (index_xyz 0 dim-2 dim-1 dim))
                           (pref x (index_xyz 0 dim-1 dim-2 dim)))))
      (pset! x (index_xyz dim-1 0 0 dim)
             (* 0.33333 (+ (pref x (index_xyz dim-2 0 0 dim))
                           (pref x (index_xyz dim-1 1 0 dim))
                           (pref x (index_xyz dim-1 0 1 dim)))))
      (pset! x (index_xyz dim-1 dim-1 0 dim)
             (* 0.33333 (+ (pref x (index_xyz dim-2 dim-1 0 dim))
                           (pref x (index_xyz dim-1 dim-2 0 dim))
                           (pref x (index_xyz dim-1 dim-1 1 dim)))))
      (pset! x (index_xyz dim-1 0 dim-1 dim)
             (* 0.33333 (+ (pref x (index_xyz dim-2 0 dim-1 dim))
                           (pref x (index_xyz dim-1 1 dim-1 dim))
                           (pref x (index_xyz dim-1 0 dim-2 dim)))))
      (pset! x (index_xyz dim-1 dim-1 dim-1 dim)
             (* 0.33333 (+ (pref x (index_xyz dim-2 dim-1 dim-1 dim))
                           (pref x (index_xyz dim-1 dim-2 dim-1 dim))
                           (pref x (index_xyz dim-1 dim-1 dim-2 dim)))))
      void)))

(bind-func fc_lin_solve
  (lambda (b:i64 x:float* x0:float* a c iter:i64 dim:i64)
    (let ((c_reciprocal (/ 1.0 c))
          (m 0)
          (i 0) (j 0) (k 0))
      (dotimes (k iter)
        (dotimes (m (- dim 2))
          (dotimes (j (- dim 2))
            (dotimes (i (- dim 2))
              (pset! x (index_xyz (+ i 1) (+ j 1) (+ m 1) dim)
                     (* c_reciprocal
                        (+ (pref x0 (index_xyz (+ i 1) (+ j 1) (+ m 1) dim))
                           (* a (+ (pref x (index_xyz (+ i 2) (+ j 1) (+ m 1) dim))
                                   (pref x (index_xyz i (+ j 1) (+ m 1) dim))
                                   (pref x (index_xyz (+ i 1) (+ j 2) (+ m 1) dim))
                                   (pref x (index_xyz (+ i 1) j (+ m 1) dim))
                                   (pref x (index_xyz (+ i 1) (+ j 1) (+ m 2) dim))
                                   (pref x (index_xyz (+ i 1) (+ j 1) m dim))))))))))
        (fc_set_boundary b x dim)))
    void))

(bind-func fc_diffuse
  (lambda (b:i64 x:float* x0:float* diff:float dt:float iter dim)
    (let ((a:float (* dt diff (convert (* (- dim 2) (- dim 2))))))
      (fc_lin_solve b x x0 a (+ 1.0 (* 6.0 a)) iter dim))))

(bind-func fc_project
  (lambda (Vx:float* Vy:float* Vz:float* p:float* div:float* iter dim)
    (let ((i 0) (j 0) (k 0))
      (dotimes (k (- dim 2))
        (dotimes (j (- dim 2))
          (dotimes (i (- dim 2))
            (pset! div (index_xyz (+ i 1) (+ j 1) (+ k 1) dim)
                   (* -0.5 (/ (+ (- (pref Vx (index_xyz (+ i 2) (+ j 1) (+ k 1) dim))
                                    (pref Vx (index_xyz i (+ j 1) (+ k 1) dim)))
                                 (- (pref Vy (index_xyz (+ i 1) (+ j 2) (+ k 1) dim))
                                    (pref Vy (index_xyz (+ i 1) j (+ k 1) dim)))
                                 (- (pref Vz (index_xyz (+ i 1) (+ j 1) (+ k 2) dim))
                                    (pref Vz (index_xyz (+ i 1) (+ j 1) k dim))))
                              (convert dim))))
            (pset! p (index_xyz (+ i 1) (+ j 1) (+ k 1) dim) 0.0))))
      (fc_set_boundary 0 div dim)
      (fc_set_boundary 0 p dim)
      (fc_lin_solve 0 p div 1.0 6.0 iter dim)
      
      (dotimes (k (- dim 2))
        (dotimes (j (- dim 2))
          (dotimes (i (- dim 2))
            (pset! Vx (index_xyz (+ i 1) (+ j 1) (+ k 1) dim)
                   (- (pref Vx (index_xyz (+ i 1) (+ j 1) (+ k 1) dim))
                      (* 0.5
                         (- (pref p (index_xyz (+ i 2) (+ j 1) (+ k 1) dim))
                            (pref p (index_xyz (+ i 0) (+ j 1) (+ k 1) dim)))
                         (convert dim))))
            (pset! Vy (index_xyz (+ i 1) (+ j 1) (+ k 1) dim)
                   (- (pref Vy (index_xyz (+ i 1) (+ j 1) (+ k 1) dim))
                      (* 0.5
                         (- (pref p (index_xyz (+ i 1) (+ j 2) (+ k 1) dim))
                            (pref p (index_xyz (+ i 1) (+ j 0) (+ k 1) dim)))
                         (convert dim))))
            (pset! Vz (index_xyz (+ i 1) (+ j 1) (+ k 1) dim)
                   (- (pref Vz (index_xyz (+ i 1) (+ j 1) (+ k 1) dim))
                      (* 0.5
                         (- (pref p (index_xyz (+ i 1) (+ j 1) (+ k 2) dim))
                            (pref p (index_xyz (+ i 1) (+ j 1) (+ k 0) dim)))
                         (convert dim)))))))
      (fc_set_boundary 1 Vx dim)
      (fc_set_boundary 2 Vy dim)
      (fc_set_boundary 3 Vz dim)
      void)))


(bind-func fc_advect
  (lambda (b:i64 d:float* d0:float* velocx:float* velocy:float* velocz:float* dt:float dim:i64)
    (let ((dtx (* dt (convert (- dim 2)))) (dty dtx) (dtz dty)
          (kfloat:float 0.0) (jfloat:float 0.0) (ifloat:float 0.0)
          (s0:float 0.0) (s1:float 0.0) (t0:float 0.0) (t1:float 0.0) (u0:float 0.0) (u1:float 0.0)
          (i0:float 0.0) (i0i:i64 0) (i1:float 0.0) (i1i:i64 0)
          (j0:float 0.0) (j0i:i64 0) (j1:float 0.0) (j1i:i64 0)
          (k 0) (j 0) (i 0)
          (tmp1:float 0.0) (tmp2:float 0.0) (tmp3:float 0.0)
          (x:float 0.0) (y:float 0.0) (z:float 0.0)
          (k0:float 0.0) (k0i:i64 0) (k1:float 0.0) (k1i:i64 0)
          (dimf (convert dim)))
      (dotimes (k (- dim 2))
        (set! kfloat (+ kfloat 1.0))
        (set! jfloat 0.0)
        (dotimes (j (- dim 2))
          (set! jfloat (+ jfloat 1.0))
          (set! ifloat 0.0)
          (dotimes (i (- dim 2))
            (set! ifloat (+ ifloat 1.0))
            (set! tmp1 (* dtx (pref velocx (index_xyz (+ i 1) (+ j 1) (+ k 1) dim))))
            (set! tmp2 (* dty (pref velocy (index_xyz (+ i 1) (+ j 1) (+ k 1) dim))))
            (set! tmp3 (* dtz (pref velocz (index_xyz (+ i 1) (+ j 1) (+ k 1) dim))))
            (set! x (- ifloat tmp1))
            (set! y (- jfloat tmp2))
            (set! z (- kfloat tmp3))
            
            (if (< x 0.5) (set! x 0.5))
            (if (> x (+ dimf 0.5)) (set! x (+ dimf 0.5)))
            (set! i0 (floor x))
            (set! i1 (+ i0 1.0))
            (if (< y 0.5) (set! y 0.5))
            (if (> y (+ dimf 0.5)) (set! y (+ dimf 0.5)))
            (set! j0 (floor y))
            (set! j1 (+ j0 1.0))
            (if (< z 0.5) (set! z 0.5))
            (if (> z (+ dimf 0.5)) (set! z (+ dimf 0.5)))
            (set! k0 (floor z))
            (set! k1 (+ k0 1.0))
            (set! s1 (- x i0))
            (set! s0 (- 1.0 s1))
            (set! t1 (- y j0))
            (set! t0 (- 1.0 t1))
            (set! u1 (- z k0))
            (set! u0 (- 1.0 u1))
            (set! i0i (convert i0))
            (set! i1i (convert i1))	      
            (set! j0i (convert j0))
            (set! j1i (convert j1))	      
            (set! k0i (convert k0))
            (set! k1i (convert k1))
            (pset! d (index_xyz (+ i 1) (+ j 1) (+ k 1) dim)
                   (+ (* s0 (+ (* t0 (+ (* u0 (pref d0 (index_xyz i0i j0i k0i dim)))
                                        (* u1 (pref d0 (index_xyz i0i j0i k1i dim)))))
                               (* t1 (+ (* u0 (pref d0 (index_xyz i0i j1i k0i dim)))
                                        (* u1 (pref d0 (index_xyz i0i j1i k1i dim)))))))
                      (* s1 (+ (* t0 (+ (* u0 (pref d0 (index_xyz i1i j0i k0i dim)))
                                        (* u1 (pref d0 (index_xyz i1i j0i k1i dim)))))
                               (* t1 (+ (* u0 (pref d0 (index_xyz i1i j1i k0i dim)))
                                        (* u1 (pref d0 (index_xyz i1i j1i k1i dim))))))))))))
      (fc_set_boundary b d dim))))

(bind-func fc_advance_timestep
  (lambda ()
    (let ((dim (tref FLUIDCUBE 0))
          (dt (tref FLUIDCUBE 1))	  
          (diff (tref FLUIDCUBE 2))
          (visc (tref FLUIDCUBE 3))	  
          (s (tref FLUIDCUBE 4))
          (i 0)
          (density (tref FLUIDCUBE 5))
          (Vx (tref FLUIDCUBE 6))
          (Vy (tref FLUIDCUBE 7))
          (Vz (tref FLUIDCUBE 8))
          (Vx0 (tref FLUIDCUBE 9))
          (Vy0 (tref FLUIDCUBE 10))
          (Vz0 (tref FLUIDCUBE 11)))
      
      (fc_diffuse 1 Vx0 Vx visc dt 4 dim)
      (fc_diffuse 2 Vy0 Vy visc dt 4 dim)
      (fc_diffuse 3 Vz0 Vz visc dt 4 dim)

      (dotimes (i (* dim dim dim))
      	(pset! Vx i 0.0)
      	(pset! Vy i 0.0)
      	(pset! Vz i 0.0))
      
      (fc_project Vx0 Vy0 Vz0 Vx Vy 4 dim)

      (fc_advect 1 Vx Vx0 Vx0 Vy0 Vz0 dt dim)
      (fc_advect 2 Vy Vy0 Vx0 Vy0 Vz0 dt dim)
      (fc_advect 3 Vz Vz0 Vx0 Vy0 Vz0 dt dim)

      (dotimes (i (* dim dim dim))
      	(pset! Vx0 i 0.0)
      	(pset! Vy0 i 0.0)
      	(pset! Vz0 i 0.0))
      
      (fc_project Vx Vy Vz Vx0 Vy0 4 dim)
      (fc_diffuse 0 s density diff dt 4 dim)
      (fc_advect 0 density s Vx Vy Vz dt dim))
    void))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Next Some OpenGL Stuff

(gl_set_view width height 200.0)

(bind-func fc_gl_setup
  (lambda ()
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA (+ GL_SRC_ALPHA 1))            
    (glDisable GL_DEPTH_TEST)))

(bind-func get_velocity
  (lambda (x y z)
    (let ((xs (tref FLUIDCUBE 6))
          (dim (tref FLUIDCUBE 0)))
      (pref xs (index_xyz x y z dim)))))

(bind-func look-at
  (lambda (eyex eyey eyez centre_x centre_y centre_z up_x up_y up_z)
    (glLoadIdentity)
    (gluLookAt eyex eyey eyez centre_x centre_y centre_z up_x up_y up_z)))

(bind-func glCube
  (let ((dlist -1))
    (lambda ()
      (if (> dlist -1)
          (begin
            (glCallList dlist)
            (set! dlist (glGenLists 1))
            (glNewList dlist (+ GL_COMPILE 1))
            (glBegin GL_QUADS)
            ;; Front face
            (glNormal3f 0. 0. 1.)
            (glVertex3f 0. 0. 1.)
            (glVertex3f 1. 0. 1.)
            (glVertex3f 1. 1. 1.)
            (glVertex3f 0. 1. 1.)
            ;; Back face
            (glNormal3f 0. 0. -1.)
            (glVertex3f 0. 0. 0.)
            (glVertex3f 0. 1. 0.)
            (glVertex3f 1. 1. 0.)
            (glVertex3f 1. 0. 0.)
            ;; Top face
            (glNormal3f 0. 1. 0.)
            (glVertex3f 0. 1. 0.)
            (glVertex3f 0. 1. 1.)
            (glVertex3f 1. 1. 1.)
            (glVertex3f 1. 1. 0.)
            ;; Bottom face
            (glNormal3f 0. -1. 0.)
            (glVertex3f 0. 0. 0.)
            (glVertex3f 1. 0. 0.)
            (glVertex3f 1. 0. 1.)
            (glVertex3f 0. 0. 1.)
            ;; Right face
            (glNormal3f 1. 0. 0.)
            (glVertex3f 1. 0. 0.)
            (glVertex3f 1. 1. 0.)
            (glVertex3f 1. 1. 1.)
            (glVertex3f 1. 0. 1.)
            ;; Left face
            (glNormal3f -1. 0. 0.)
            (glVertex3f 0. 0. 0.)
            (glVertex3f 0. 0. 1.)
            (glVertex3f 0. 1. 1.)
            (glVertex3f 0. 1. 0.)
            (glEnd)
            (glEndList)
            void)))))

;; a trivial opengl draw loop
(bind-func gl_loop
  (lambda (degree:float)
    ;; (glClearColor 1.0 0.5 0.0 1.0)
    (fc_advance_timestep)
    (let ((i 0) (j 0) (k 0)
          (dim (tref FLUIDCUBE 0))
          (dimf:float (convert dim))
          (densities (tref FLUIDCUBE 5))	    
          (Vx (tref FLUIDCUBE 6))
          (Vy (tref FLUIDCUBE 7))
          (Vz (tref FLUIDCUBE 8)))
      (glClearColor 0.0 0.0 0.0 1.0)      
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (glColor4f 0.0 0.0 0.0 1.0)
      (glLineWidth 1.0)
      (glLoadIdentity)
      (glTranslatef -1. -1. -10.)
      ;; (glScalef (* 2. (/ 1. dimf)) (* 2. (/ 1. dimf)) (* 2. (/ 1. dimf)))
      (glScalef .1 .1 .1)
      (glTranslatef 10. 11. 11.)
      (glRotatef (* 300.0 degree) 0.0 1.0 0.0)
      (glTranslatef -10. -11. -11.)
      ;; (glTranslatef (* -1. dimf) (* -1. dimf) (* -1. dimf))
      
      (dotimes (i 0 dim)
        (dotimes (j 0 dim)
          (dotimes (k 0 dim)
            (let ((idx (index_xyz i j k dim))
                  (norm (sqrt (+ (* (pref Vx idx) (pref Vx idx))
                                 (* (pref Vy idx) (pref Vy idx))
                                 (* (pref Vz idx) (pref Vz idx))))))
              (glPushMatrix)
              (glTranslatef (convert i) (convert j) (convert k))
              (glColor4f 0.8 1.0 0.4 (pref densities idx))
              (glCube)
              ;; turn 0.2 to 0.0 to stop drawing vertex arrows
              (glColor4f 1. 0. 0. 1.)
              ;; if you're having performance problems you
              ;; could start by commenting out the next 4 lines
              ;; i.e. stop drawing the red velocity arrows
              (glBegin GL_LINES)
              (glVertex3f .5 .5 .5)
              (glVertex3f (+ .5 (* .5 (/ (pref Vx idx) norm)))
                          (+ .5 (* .5 (/ (pref Vy idx) norm)))
                          (+ .5 (* .5 (/ (pref Vz idx) norm))))
              (glEnd)
              (glPopMatrix))))))
    void))

;; create the fluidcube

(fc_create 20 0.001 0.001 0.001)

;; gl-loop includes two sources
;; of constant wind speed
;;
;; bottom->top: straight up the middle
;; left->right: oscillates from back to front
;;
;; You might need to slow the rate of this
;; temporal recursion down if your machine
;; doesn't cope.  (i.e. 3000 to 5000 or more
(define gl-loop
  (lambda (time fps degree)
    (gl_loop degree)
    ;; 1000.0 is wind speed from bottom to top
    (fc_add_velocity 11 1 11 0.0 1000.0 0.0)
    ;; 600.0 is wind speed from left to right
    (fc_add_velocity 2 5 11 300.0 0.0 (+ 200.0 (* 200.0 (cos (* 100.0 degree)))))
    ;; everynow and then remove smoke from cube
    (if (< (modulo degree 1.0) 0.005) (fc_clean))
    (gl:swap-buffers *gl-ctx*)
    (callback time 'gl-loop (+ time (/ *second* fps)) fps (+ degree 0.01))))

;; Smoke signal injects smoke into the system
;; at semi-regular intervals (* 40000 (random 4 9))
(define smoke-signal
  (lambda (time)
    ;; increase 300.0 to kick more smoke into the system 
    (fc_add_density 2 5 11 (+ 1.0 (* (random) 200.0)))    
    ;; decrease (random 4 9) to inject smoke more often
    (callback (+ time 4410) 'smoke-signal (+ time (* *second* (random 4 9))))))


(gl-loop (now) 1 0.0)
(fc_gl_setup)
(smoke-signal (now))

;; eval this again if you want to clean the cube at some point!
; (fc_clean)
